### /Users/robinsongarcia/projects/gnomonic/projection/__init__.py ###
### /Users/robinsongarcia/projects/gnomonic/projection/__init__.py ###

"""
Gnomonic Projection Package

This package provides functionalities for gnomonic projections,
including registry management and default projection registration.
"""

from .registry import ProjectionRegistry
from .default_projections import register_default_projections
from .logging_config import setup_logging

# Set up logging
logger = setup_logging()
logger.info("Initializing Gnomonic Projection Package")

# Automatically register default projections
try:
    register_default_projections()
    logger.info("Default projections registered successfully.")
except Exception as e:
    logger.exception("Failed to register default projections.")
    raise RuntimeError("Failed to register default projections.") from e

__all__ = ["ProjectionRegistry"]

### /Users/robinsongarcia/projects/gnomonic/projection/base/__init__.py ###
### /Users/robinsongarcia/projects/gnomonic/projection/base/__init__.py ###

"""
Base module for gnomonic projection components.

This module includes base classes for projection configuration,
strategy, grid generation, interpolation, and coordinate transformations.
"""

from .config import BaseProjectionConfig
from .strategy import BaseProjectionStrategy
from .grid import BaseGridGeneration
from .interpolation import BaseInterpolation
from .transform import CoordinateTransformer
from ..exceptions import (
    ProjectionError,
    ConfigurationError,
    RegistrationError,
    ProcessingError,
    GridGenerationError,
    TransformationError,
    InterpolationError,
)

__all__ = [
    "BaseProjectionConfig",
    "BaseProjectionStrategy",
    "BaseGridGeneration",
    "BaseInterpolation",
    "CoordinateTransformer",
    "ProjectionError",
    "ConfigurationError",
    "RegistrationError",
    "ProcessingError",
    "GridGenerationError",
    "TransformationError",
    "InterpolationError",
]

### /Users/robinsongarcia/projects/gnomonic/projection/base/config.py ###
from typing import Any, Dict, Optional
from pydantic import BaseModel, Field, validator
from ..base.interpolation import BaseInterpolation
from ..exceptions import ConfigurationError
import logging

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.base.config')

class BaseProjectionConfigModel(BaseModel):
    interpolation: Optional[int] = Field(default=0, description="Interpolation method for OpenCV remap")
    borderMode: Optional[int] = Field(default=0, description="Border mode for OpenCV remap")
    borderValue: Optional[Any] = Field(default=0, description="Border value for OpenCV remap")
    # Add other common configuration parameters if necessary

    class Config:
        arbitrary_types_allowed = True

class BaseProjectionConfig:
    """
    Base class for projections, allowing dynamic initialization with configuration objects.
    Utilizes Pydantic for configuration validation and management.
    """
    def __init__(self, config_object: Any) -> None:
        """
        Initialize the projection configuration.

        Args:
            config_object (Any): An object (e.g., GnomonicConfig) containing configuration parameters.

        Raises:
            ConfigurationError: If the configuration object does not have a 'config' attribute.
        """
        logger.debug("Initializing BaseProjectionConfig.")
        if not hasattr(config_object, "config"):
            error_msg = "Configuration object must have a 'config' attribute."
            logger.error(error_msg)
            raise ConfigurationError(error_msg)
        self.config_object: Any = config_object
        try:
            self.params: BaseProjectionConfigModel = config_object.config
            logger.debug("Configuration parameters loaded successfully.")
        except Exception as e:
            error_msg = f"Failed to load configuration parameters: {e}"
            logger.exception(error_msg)
            raise ConfigurationError(error_msg) from e
        self.extra_params: Dict[str, Any] = {}

    def create_projection(self) -> Any:
        """
        Placeholder for creating a projection object.
        Subclasses or dynamic creation logic should override this method.

        Raises:
            NotImplementedError: If the method is not overridden by subclasses.
        """
        logger.debug("create_projection method called.")
        raise NotImplementedError("Subclasses or configuration must implement create_projection.")

    def create_grid_generation(self) -> Any:
        """
        Placeholder for creating a grid generation object.
        Subclasses or dynamic creation logic should override this method.

        Raises:
            NotImplementedError: If the method is not overridden by subclasses.
        """
        logger.debug("create_grid_generation method called.")
        raise NotImplementedError("Subclasses or configuration must implement create_grid_generation.")

    def create_interpolation(self) -> BaseInterpolation:
        """
        Create an interpolation object using the configuration.

        Returns:
            BaseInterpolation: The interpolation object.
        """
        logger.debug("Creating interpolation object.")
        return BaseInterpolation(self)

    def create_transformer(self) -> Any:
        """
        Placeholder for creating a transformer object.

        Raises:
            NotImplementedError: If the method is not overridden by subclasses.
        """
        logger.debug("create_transformer method called.")
        raise NotImplementedError("Subclasses or configuration must implement create_transformer.")

    def update(self, **kwargs: Any) -> None:
        """
        Update configuration parameters dynamically.

        Args:
            **kwargs (Any): Parameters to update in the configuration.
        """
        logger.debug(f"Updating configuration with parameters: {kwargs}")
        for key, value in kwargs.items():
            if key in self.params.__fields__:
                try:
                    setattr(self.params, key, value)
                    logger.debug(f"Parameter '{key}' updated to {value}.")
                except Exception as e:
                    error_msg = f"Failed to update parameter '{key}': {e}"
                    logger.exception(error_msg)
                    raise ConfigurationError(error_msg) from e
            else:
                self.extra_params[key] = value
                logger.debug(f"Extra parameter '{key}' set to {value}.")

    def __getattr__(self, item: str) -> Any:
        """
        Access configuration parameters as attributes.

        Args:
            item (str): Parameter name.

        Returns:
            Any: The value of the parameter if it exists.

        Raises:
            AttributeError: If the parameter does not exist.
        """
        logger.debug(f"Accessing attribute '{item}'.")
        if hasattr(self.params, item):
            return getattr(self.params, item)
        if item in self.extra_params:
            return self.extra_params[item]
        error_msg = f"'{type(self).__name__}' object has no attribute '{item}'"
        logger.error(error_msg)
        raise AttributeError(error_msg)

    def __repr__(self) -> str:
        """
        String representation of the configuration.

        Returns:
            str: Human-readable string of configuration parameters.
        """
        return f"BaseProjectionConfig(params={self.params.dict()}, extra_params={self.extra_params})"

### /Users/robinsongarcia/projects/gnomonic/projection/base/grid.py ###
### /Users/robinsongarcia/projects/gnomonic/projection/base/grid.py ###

from typing import Any, Tuple
import numpy as np
import logging
from ..exceptions import GridGenerationError, ProcessingError

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.base.grid')

class BaseGridGeneration:
    """
    Base class for grid generation in projections.
    """
    def create_grid(self, direction: str) -> Tuple[np.ndarray, np.ndarray]:
        """
        Create a grid based on the specified direction.

        Args:
            direction (str): Direction of grid creation ('forward' or 'backward').

        Returns:
            Tuple[np.ndarray, np.ndarray]: Generated grid arrays.

        Raises:
            GridGenerationError: If the direction is invalid or method is not overridden.
        """
        logger.debug(f"Creating grid with direction '{direction}'.")
        if direction not in ('forward', 'backward'):
            error_msg = "Direction must be 'forward' or 'backward'."
            logger.error(error_msg)
            raise GridGenerationError(error_msg)
        logger.debug(f"Direction '{direction}' is valid.")
        try:
            # Attempt to call the overridden method in subclasses
            return self._create_grid(direction)
        except NotImplementedError as e:
            error_msg = "Subclasses must implement create_grid."
            logger.error(error_msg)
            raise GridGenerationError(error_msg) from e
        except Exception as e:
            error_msg = f"An unexpected error occurred while creating grid: {e}"
            logger.exception(error_msg)
            raise GridGenerationError(error_msg) from e

    def _create_grid(self, direction: str) -> Tuple[np.ndarray, np.ndarray]:
        """
        Internal method to be overridden by subclasses for grid creation.

        Args:
            direction (str): Direction of grid creation.

        Raises:
            NotImplementedError: If not overridden by subclasses.
        """
        logger.debug("BaseGridGeneration._create_grid called - should be overridden.")
        raise NotImplementedError("Subclasses must implement _create_grid.")

### /Users/robinsongarcia/projects/gnomonic/projection/base/interpolation.py ###
### /Users/robinsongarcia/projects/gnomonic/projection/base/interpolation.py ###

from typing import Any, Optional
import cv2
import numpy as np
import logging
from ..exceptions import InterpolationError

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.base.interpolation')

class BaseInterpolation:
    """
    Base class for image interpolation in projections.
    """
    def __init__(self, config: Any) -> None:
        """
        Initialize the interpolation with the given configuration.

        Args:
            config (Any): The projection configuration.

        Raises:
            TypeError: If 'config' does not have required attributes.
        """
        logger.debug("Initializing BaseInterpolation.")
        if not hasattr(config, "interpolation") or not hasattr(config, "borderMode") or not hasattr(config, "borderValue"):
            error_msg = "Config must have 'interpolation', 'borderMode', and 'borderValue' attributes."
            logger.error(error_msg)
            raise TypeError(error_msg)
        self.config: Any = config
        logger.info("BaseInterpolation initialized successfully.")

    def interpolate(
        self, 
        input_img: np.ndarray, 
        map_x: np.ndarray, 
        map_y: np.ndarray, 
        mask: Optional[np.ndarray] = None
    ) -> np.ndarray:
        """
        Perform image interpolation based on the provided mapping.

        Args:
            input_img (np.ndarray): The input image to interpolate.
            map_x (np.ndarray): The mapping for the x-coordinates.
            map_y (np.ndarray): The mapping for the y-coordinates.
            mask (Optional[np.ndarray], optional): Mask to apply to the interpolated image. Defaults to None.

        Returns:
            np.ndarray: The interpolated image.

        Raises:
            InterpolationError: If OpenCV remap fails or inputs are invalid.
        """
        logger.debug("Starting image interpolation.")
        if not isinstance(input_img, np.ndarray):
            error_msg = "input_img must be a NumPy ndarray."
            logger.error(error_msg)
            raise InterpolationError(error_msg)
        if not isinstance(map_x, np.ndarray) or not isinstance(map_y, np.ndarray):
            error_msg = "map_x and map_y must be NumPy ndarrays."
            logger.error(error_msg)
            raise InterpolationError(error_msg)

        try:
            map_x_32: np.ndarray = map_x.astype(np.float32)
            map_y_32: np.ndarray = map_y.astype(np.float32)
            logger.debug("map_x and map_y converted to float32 successfully.")
        except Exception as e:
            error_msg = f"Failed to convert map_x or map_y to float32: {e}"
            logger.exception(error_msg)
            raise InterpolationError(error_msg) from e

        try:
            result: np.ndarray = cv2.remap(
                input_img, map_x_32, map_y_32,
                interpolation=self.config.interpolation,
                borderMode=self.config.borderMode,
                borderValue=self.config.borderValue
            )
            logger.debug("OpenCV remap executed successfully.")
        except cv2.error as e:
            error_msg = f"OpenCV remap failed: {e}"
            logger.exception(error_msg)
            raise InterpolationError(error_msg) from e

        if mask is not None:
            logger.debug("Applying mask to interpolated image.")
            if not isinstance(mask, np.ndarray):
                error_msg = "mask must be a NumPy ndarray if provided."
                logger.error(error_msg)
                raise InterpolationError(error_msg)
            if mask.shape != result.shape[:2]:
                error_msg = "mask shape must match the first two dimensions of the result."
                logger.error(error_msg)
                raise InterpolationError(error_msg)
            result *= mask[:, :, None]
            logger.debug("Mask applied successfully.")

        logger.info("Image interpolation completed successfully.")
        return result

### /Users/robinsongarcia/projects/gnomonic/projection/base/strategy.py ###
### /Users/robinsongarcia/projects/gnomonic/projection/base/strategy.py ###

from typing import Any, Tuple
import numpy as np
import logging
from ..exceptions import ProcessingError

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.base.strategy')

class BaseProjectionStrategy:
    """
    Base class for projection strategies.
    """
    def forward(self, x: np.ndarray, y: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        Perform forward projection from grid coordinates to latitude and longitude.

        Args:
            x (np.ndarray): X-coordinates in the grid.
            y (np.ndarray): Y-coordinates in the grid.

        Returns:
            Tuple[np.ndarray, np.ndarray]: Latitude and longitude arrays.

        Raises:
            ProcessingError: If inputs are not valid NumPy arrays or method is not overridden.
        """
        logger.debug("Starting forward projection in BaseProjectionStrategy.")
        if not isinstance(x, np.ndarray) or not isinstance(y, np.ndarray):
            error_msg = "x and y must be NumPy ndarrays."
            logger.error(error_msg)
            raise ProcessingError(error_msg)
        logger.debug("Forward projection inputs are valid.")
        raise NotImplementedError("Subclasses must implement forward.")

    def backward(self, lat: np.ndarray, lon: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Perform backward projection from latitude and longitude to grid coordinates.

        Args:
            lat (np.ndarray): Latitude values.
            lon (np.ndarray): Longitude values.

        Returns:
            Tuple[np.ndarray, np.ndarray, np.ndarray]: X and Y coordinates in the grid, and a mask array.

        Raises:
            ProcessingError: If inputs are not valid NumPy arrays or method is not overridden.
        """
        logger.debug("Starting backward projection in BaseProjectionStrategy.")
        if not isinstance(lat, np.ndarray) or not isinstance(lon, np.ndarray):
            error_msg = "lat and lon must be NumPy ndarrays."
            logger.error(error_msg)
            raise ProcessingError(error_msg)
        logger.debug("Backward projection inputs are valid.")
        raise NotImplementedError("Subclasses must implement backward.")

### /Users/robinsongarcia/projects/gnomonic/projection/base/transform.py ###
from typing import Any, Tuple
import numpy as np
import logging
from ..exceptions import TransformationError, ConfigurationError

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.base.transform')

class CoordinateTransformer:
    """
    Utility class for transforming coordinates between different systems.
    """

    @staticmethod
    def latlon_to_image_coords(
        lat: np.ndarray, 
        lon: np.ndarray, 
        config: Any, 
        shape: Tuple[int, int, ...]
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Convert latitude and longitude to image coordinates.

        Args:
            lat (np.ndarray): Latitude values.
            lon (np.ndarray): Longitude values.
            config (Any): Configuration object containing grid parameters.
            shape (Tuple[int, int, ...]): Shape of the target image (height, width, ...).

        Returns:
            Tuple[np.ndarray, np.ndarray]: X and Y coordinates in image space.

        Raises:
            TransformationError: If input arrays are invalid or computation fails.
            ConfigurationError: If config lacks required attributes.
        """
        logger.debug("Transforming latitude and longitude to image coordinates.")
        if not isinstance(lat, np.ndarray) or not isinstance(lon, np.ndarray):
            error_msg = "lat and lon must be NumPy ndarrays."
            logger.error(error_msg)
            raise TransformationError(error_msg)
        if not hasattr(config, "lon_min") or not hasattr(config, "lon_max") \
           or not hasattr(config, "lat_min") or not hasattr(config, "lat_max"):
            error_msg = "config must have 'lon_min', 'lon_max', 'lat_min', and 'lat_max' attributes."
            logger.error(error_msg)
            raise ConfigurationError(error_msg)

        if len(shape) < 2:
            error_msg = "Image shape must have at least two dimensions (height, width)."
            logger.error(error_msg)
            raise TransformationError(error_msg)

        H, W = shape[:2]
        try:
            map_x = (lon - config.lon_min) / (config.lon_max - config.lon_min) * (W - 1)
            map_y = (config.lat_max - lat) / (config.lat_max - config.lat_min) * (H - 1)
            logger.debug("Computed image coordinates successfully.")
        except Exception as e:
            error_msg = f"Failed to compute image coordinates: {e}"
            logger.exception(error_msg)
            raise TransformationError(error_msg) from e

        return map_x, map_y

    @staticmethod
    def xy_to_image_coords(
        x: np.ndarray, 
        y: np.ndarray, 
        config: Any
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Convert X and Y grid coordinates to image coordinates.

        Args:
            x (np.ndarray): X coordinates in grid space.
            y (np.ndarray): Y coordinates in grid space.
            config (Any): Configuration object containing grid parameters.

        Returns:
            Tuple[np.ndarray, np.ndarray]: X and Y coordinates in image space.

        Raises:
            TransformationError: If input arrays are invalid or computation fails.
        """
        logger.debug("Transforming grid coordinates (x, y) to image coordinates.")
        if not isinstance(x, np.ndarray) or not isinstance(y, np.ndarray):
            error_msg = "x and y must be NumPy ndarrays."
            logger.error(error_msg)
            raise TransformationError(error_msg)

        try:
            # Compute grid bounds dynamically based on FOV
            half_fov_rad = np.deg2rad(config.fov_deg / 2)
            x_max = np.tan(half_fov_rad) * config.R
            y_max = np.tan(half_fov_rad) * config.R
            x_min, y_min = -x_max, -y_max

            # Transform grid coordinates to image coordinates
            map_x = (x - x_min) / (x_max - x_min) * (config.x_points - 1)
            map_y = (y_max - y) / (y_max - y_min) * (config.y_points - 1)
            logger.debug("Grid coordinates transformed to image coordinates successfully.")
        except Exception as e:
            error_msg = f"Failed to compute image coordinates: {e}"
            logger.exception(error_msg)
            raise TransformationError(error_msg) from e

        return map_x, map_y

### /Users/robinsongarcia/projects/gnomonic/projection/default_projections.py ###
from .registry import ProjectionRegistry

from .gnomonic.config import GnomonicConfig
from .gnomonic.grid import GnomonicGridGeneration
from .gnomonic.strategy import GnomonicProjectionStrategy
from .gnomonic.transform import GnomonicTransformer  # Updated to per-projection transformer

from .mercator.config import MercatorConfig
from .mercator.grid import MercatorGridGeneration
from .mercator.strategy import MercatorProjectionStrategy
from .mercator.transform import MercatorTransformer  # Updated to per-projection transformer

from .base.interpolation import BaseInterpolation
from .exceptions import RegistrationError
import logging

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.default_projections')


def register_default_projections():
    """
    Register default projections with their components.
    """
    logger.debug("Registering default projections.")
    try:
        # Register Gnomonic projection
        ProjectionRegistry.register("gnomonic", {
            "config": GnomonicConfig,
            "grid_generation": GnomonicGridGeneration,
            "projection_strategy": GnomonicProjectionStrategy,
            "interpolation": BaseInterpolation,
            "transformer": GnomonicTransformer,  # Updated to GnomonicTransformer
        })
        logger.info("Default projection 'gnomonic' registered successfully.")

        # Register Mercator projection
        ProjectionRegistry.register("mercator", {
            "config": MercatorConfig,
            "grid_generation": MercatorGridGeneration,
            "projection_strategy": MercatorProjectionStrategy,
            "interpolation": BaseInterpolation,
            "transformer": MercatorTransformer,  # Updated to MercatorTransformer
        })
        logger.info("Default projection 'mercator' registered successfully.")

    except RegistrationError as e:
        logger.exception("Failed to register default projections.")
        raise RegistrationError(f"Failed to register default projections: {e}") from e
    except Exception as e:
        logger.exception("An unexpected error occurred while registering default projections.")
        raise RegistrationError(f"An unexpected error occurred: {e}") from e

    logger.debug("All default projections registered.")

### /Users/robinsongarcia/projects/gnomonic/projection/exceptions.py ###
### /Users/robinsongarcia/projects/gnomonic/projection/exceptions.py ###

"""
Custom exception classes for the Gnomonic Projection module.
"""

class ProjectionError(Exception):
    """Base exception for projection-related errors."""
    pass

class ConfigurationError(ProjectionError):
    """Exception raised for configuration-related issues."""
    pass

class RegistrationError(ProjectionError):
    """Exception raised during projection registration."""
    pass

class ProcessingError(ProjectionError):
    """Exception raised during projection processing."""
    pass

class GridGenerationError(ProjectionError):
    """Exception raised during grid generation."""
    pass

class TransformationError(ProjectionError):
    """Exception raised during coordinate transformations."""
    pass

class InterpolationError(ProjectionError):
    """Exception raised during image interpolation."""
    pass

### /Users/robinsongarcia/projects/gnomonic/projection/gnomonic/__init__.py ###
### /Users/robinsongarcia/projects/gnomonic/projection/gnomonic/__init__.py ###

"""
Gnomonic Projection Module

This module provides specific implementations for Gnomonic projections,
including configuration, projection strategies, and grid generation.
"""

import logging

from .config import GnomonicConfig
from .strategy import GnomonicProjectionStrategy
from .grid import GnomonicGridGeneration
from ..logging_config import setup_logging

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.gnomonic')

def initialize_gnomonic_module():
    """
    Initialize the Gnomonic Projection module.
    """
    logger.debug("Initializing Gnomonic Projection Module.")
    # Any module-specific initialization can be done here
    logger.info("Gnomonic Projection Module initialized successfully.")

# Call the initialization function upon import
initialize_gnomonic_module()

__all__ = [
    "GnomonicConfig",
    "GnomonicProjectionStrategy",
    "GnomonicGridGeneration",
]

### /Users/robinsongarcia/projects/gnomonic/projection/gnomonic/config.py ###
from typing import Any, Optional
from pydantic import BaseModel, Field, validator
import cv2
import logging
from ..exceptions import ConfigurationError

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.gnomonic.config')

class GnomonicConfigModel(BaseModel):
    R: float = Field(1.0, description="Radius of the sphere")
    phi1_deg: float = Field(0.0, description="Latitude of the projection center")
    lam0_deg: float = Field(0.0, description="Longitude of the projection center")
    fov_deg: float = Field(90.0, description="Field of view in degrees")
    x_points: int = Field(512, description="Number of grid points in x-direction")
    y_points: int = Field(512, description="Number of grid points in y-direction")
    lon_points: int = Field(1024, description="Number of longitude points for backward grid")
    lat_points: int = Field(512, description="Number of latitude points for backward grid")
    lon_min: float = Field(-180.0, description="Minimum longitude in the grid")
    lon_max: float = Field(180.0, description="Maximum longitude in the grid")
    lat_min: float = Field(-90.0, description="Minimum latitude in the grid")
    lat_max: float = Field(90.0, description="Maximum latitude in the grid")
    interpolation: Optional[int] = Field(default=cv2.INTER_LINEAR, description="Interpolation method for OpenCV remap")
    borderMode: Optional[int] = Field(default=cv2.BORDER_CONSTANT, description="Border mode for OpenCV remap")
    borderValue: Optional[Any] = Field(default=0, description="Border value for OpenCV remap")

    @validator('fov_deg')
    def validate_fov(cls, v):
        if not (0 < v < 180):
            raise ValueError("Field of view (fov_deg) must be between 0 and 180 degrees.")
        return v

    class Config:
        arbitrary_types_allowed = True

class GnomonicConfig:
    """
    Configuration class for Gnomonic projections using Pydantic for validation.
    """
    def __init__(self, **kwargs: Any) -> None:
        logger.debug("Initializing GnomonicConfig with parameters: %s", kwargs)
        try:
            self.config = GnomonicConfigModel(**kwargs)
            logger.info("GnomonicConfig initialized successfully.")
        except Exception as e:
            error_msg = f"Failed to initialize GnomonicConfig: {e}"
            logger.exception(error_msg)
            raise ConfigurationError(error_msg) from e

    def update(self, **kwargs: Any) -> None:
        logger.debug(f"Updating GnomonicConfig with parameters: {kwargs}")
        try:
            updated_config = self.config.copy(update=kwargs)
            self.config = updated_config
            logger.info("GnomonicConfig updated successfully.")
        except Exception as e:
            error_msg = f"Failed to update GnomonicConfig: {e}"
            logger.exception(error_msg)
            raise ConfigurationError(error_msg) from e

    def __getattr__(self, item: str) -> Any:
        logger.debug(f"Accessing GnomonicConfig attribute '{item}'.")
        try:
            return getattr(self.config, item)
        except AttributeError:
            error_msg = f"'GnomonicConfig' object has no attribute '{item}'"
            logger.error(error_msg)
            raise AttributeError(error_msg) from None

    def __repr__(self) -> str:
        return f"GnomonicConfig({self.config.dict()})"

### /Users/robinsongarcia/projects/gnomonic/projection/gnomonic/grid.py ###
from typing import Any, Tuple
from ..base.grid import BaseGridGeneration
from .config import GnomonicConfig
from ..exceptions import GridGenerationError
import numpy as np
import logging

logger = logging.getLogger('gnomonic_projection.gnomonic.grid')

class GnomonicGridGeneration(BaseGridGeneration):
    def __init__(self, config: GnomonicConfig) -> None:
        logger.debug("Initializing GnomonicGridGeneration.")
        if not isinstance(config, GnomonicConfig):
            error_msg = f"config must be an instance of GnomonicConfig, got {type(config)} instead."
            logger.error(error_msg)
            raise TypeError(error_msg)
        self.config: GnomonicConfig = config
        logger.info("GnomonicGridGeneration initialized successfully.")

    def _create_grid(self, direction: str) -> Tuple[np.ndarray, np.ndarray]:
        logger.debug(f"GnomonicGridGeneration: Creating '{direction}' grid.")
        if direction == 'forward':
            try:
                half_fov_rad = np.deg2rad(self.config.fov_deg / 2)
                x_max = np.tan(half_fov_rad) * self.config.R
                y_max = np.tan(half_fov_rad) * self.config.R
                x_vals = np.linspace(-x_max, x_max, self.config.x_points)
                y_vals = np.linspace(-y_max, y_max, self.config.y_points)
                grid_x, grid_y = np.meshgrid(x_vals, y_vals)
                logger.debug("Forward grid created successfully with dynamic FOV.")
                return grid_x, grid_y
            except Exception as e:
                error_msg = f"Failed to create forward grid: {e}"
                logger.exception(error_msg)
                raise GridGenerationError(error_msg) from e
        elif direction == 'backward':
            try:
                lon_vals = np.linspace(self.config.lon_min, self.config.lon_max, self.config.lon_points)
                lat_vals = np.linspace(self.config.lat_min, self.config.lat_max, self.config.lat_points)
                grid_lon, grid_lat = np.meshgrid(lon_vals, lat_vals)
                logger.debug("Backward grid created successfully.")
                return grid_lon, grid_lat
            except Exception as e:
                error_msg = f"Failed to create backward grid: {e}"
                logger.exception(error_msg)
                raise GridGenerationError(error_msg) from e
        else:
            error_msg = "Direction must be 'forward' or 'backward'."
            logger.error(error_msg)
            raise GridGenerationError(error_msg)

### /Users/robinsongarcia/projects/gnomonic/projection/gnomonic/strategy.py ###
from typing import Any, Tuple
from ..base.strategy import BaseProjectionStrategy
from .config import GnomonicConfig
from ..exceptions import ProcessingError
import numpy as np
import logging

logger = logging.getLogger('gnomonic_projection.gnomonic.strategy')

class GnomonicProjectionStrategy(BaseProjectionStrategy):
    def __init__(self, config: GnomonicConfig) -> None:
        logger.debug("Initializing GnomonicProjectionStrategy.")
        if not isinstance(config, GnomonicConfig):
            error_msg = f"config must be an instance of GnomonicConfig, got {type(config)} instead."
            logger.error(error_msg)
            raise TypeError(error_msg)
        self.config: GnomonicConfig = config
        logger.info("GnomonicProjectionStrategy initialized successfully.")

    def forward(self, x: np.ndarray, y: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        logger.debug("Starting forward Gnomonic projection.")
        try:
            phi1_rad, lam0_rad = np.deg2rad([self.config.phi1_deg, self.config.lam0_deg])
            rho = np.sqrt(x**2 + y**2)
            c = np.arctan2(rho, self.config.R)
            sin_c, cos_c = np.sin(c), np.cos(c)
            phi = np.arcsin(cos_c * np.sin(phi1_rad) - (y * sin_c * np.cos(phi1_rad)) / rho)
            lam = lam0_rad + np.arctan2(x * sin_c, rho * np.cos(phi1_rad) * cos_c + y * np.sin(phi1_rad) * sin_c)
            lat = np.rad2deg(phi)
            lon = np.rad2deg(lam)
            logger.debug("Forward Gnomonic projection computed successfully.")
            return lat, lon
        except Exception as e:
            error_msg = f"Failed during forward Gnomonic projection: {e}"
            logger.exception(error_msg)
            raise ProcessingError(error_msg) from e

    def backward(self, lat: np.ndarray, lon: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        logger.debug("Starting backward Gnomonic projection.")
        try:
            phi1_rad, lam0_rad = np.deg2rad([self.config.phi1_deg, self.config.lam0_deg])
            phi_rad, lam_rad = np.deg2rad([lat, lon])
            cos_c = np.sin(phi1_rad) * np.sin(phi_rad) + np.cos(phi1_rad) * np.cos(phi_rad) * np.cos(lam_rad - lam0_rad)
            cos_c = np.where(cos_c == 0, 1e-10, cos_c)
            x = self.config.R * np.cos(phi_rad) * np.sin(lam_rad - lam0_rad) / cos_c
            y = self.config.R * (np.cos(phi1_rad) * np.sin(phi_rad) - np.sin(phi1_rad) * np.cos(phi_rad) * np.cos(lam_rad - lam0_rad)) / cos_c
            mask = cos_c > 0
            logger.debug("Backward Gnomonic projection computed successfully.")
            return x, y, mask
        except Exception as e:
            error_msg = f"Failed during backward Gnomonic projection: {e}"
            logger.exception(error_msg)
            raise ProcessingError(error_msg) from e

### /Users/robinsongarcia/projects/gnomonic/projection/gnomonic/transform.py ###
from typing import Tuple, Any
import numpy as np
import logging
from ..exceptions import TransformationError, ConfigurationError

logger = logging.getLogger('projection.gnomonic.transform')

class GnomonicTransformer:
    """
    Transformation logic for Gnomonic projection.
    """
    def __init__(self, config):
        """
        Initialize the GnomonicTransformer with the given configuration.

        Args:
            config: Configuration object with necessary parameters.
        """
        if not hasattr(config, "lon_min") or not hasattr(config, "lon_max") \
           or not hasattr(config, "lat_min") or not hasattr(config, "lat_max") \
           or not hasattr(config, "fov_deg") or not hasattr(config, "R"):
            error_msg = "Configuration object is missing required attributes."
            logger.error(error_msg)
            raise ConfigurationError(error_msg)
        
        self.config = config  # Store the configuration object
        logger.info("GnomonicTransformer initialized successfully.")

    def _validate_inputs(self, array: np.ndarray, name: str) -> None:
        """
        Validate input arrays to ensure they are NumPy arrays.

        Args:
            array (np.ndarray): Input array to validate.
            name (str): Name of the array for error messages.

        Raises:
            TransformationError: If the input is invalid.
        """
        if not isinstance(array, np.ndarray):
            error_msg = f"{name} must be a NumPy ndarray."
            logger.error(error_msg)
            raise TransformationError(error_msg)

    def _compute_image_coords(self, values: np.ndarray, min_val: float, max_val: float, size: int) -> np.ndarray:
        """
        Generalized method to compute normalized image coordinates.

        Args:
            values (np.ndarray): Input values (e.g., lat, lon, x, or y).
            min_val (float): Minimum value for normalization.
            max_val (float): Maximum value for normalization.
            size (int): Size of the target axis (width or height).

        Returns:
            np.ndarray: Normalized image coordinates.
        """
        return (values - min_val) / (max_val - min_val) * (size - 1)

    def latlon_to_image_coords(
        self, lat: np.ndarray, lon: np.ndarray, shape: Tuple[int, int]
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Convert latitude and longitude to Gnomonic image coordinates.

        Args:
            lat (np.ndarray): Latitude values.
            lon (np.ndarray): Longitude values.
            shape (Tuple[int, int]): Shape of the target image (height, width).

        Returns:
            Tuple[np.ndarray, np.ndarray]: X and Y coordinates in image space.

        Raises:
            TransformationError: If input arrays are invalid or computation fails.
        """
        logger.debug("Transforming latitude and longitude to image coordinates.")
        try:
            self._validate_inputs(lat, "lat")
            self._validate_inputs(lon, "lon")
            H, W = shape
            map_x = self._compute_image_coords(lon, self.config.lon_min, self.config.lon_max, W)
            map_y = self._compute_image_coords(lat, self.config.lat_max, self.config.lat_min, H)
            logger.debug("Latitude and longitude transformed successfully.")
            return map_x, map_y
        except Exception as e:
            logger.exception("Failed to transform latitude and longitude to image coordinates.")
            raise TransformationError(f"Gnomonic lat/lon transformation failed: {e}")

    def xy_to_image_coords(self, x: np.ndarray, y: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        Transform XY grid coordinates to image coordinates.

        Args:
            x (np.ndarray): X grid coordinates.
            y (np.ndarray): Y grid coordinates.

        Returns:
            Tuple[np.ndarray, np.ndarray]: Image coordinates.

        Raises:
            TransformationError: If input arrays are invalid or computation fails.
        """
        logger.debug("Transforming XY grid coordinates to image coordinates.")
        try:
            self._validate_inputs(x, "x")
            self._validate_inputs(y, "y")

            half_fov_rad = np.deg2rad(self.config.fov_deg / 2)
            x_max = np.tan(half_fov_rad) * self.config.R
            y_max = np.tan(half_fov_rad) * self.config.R
            x_min, y_min = -x_max, -y_max

            map_x = self._compute_image_coords(x, x_min, x_max, self.config.x_points)
            map_y = self._compute_image_coords(y, y_max, y_min, self.config.y_points)
            logger.debug("XY grid coordinates transformed successfully.")
            return map_x, map_y
        except Exception as e:
            logger.exception("Failed to transform XY grid coordinates to image coordinates.")
            raise TransformationError(f"Gnomonic XY transformation failed: {e}")

### /Users/robinsongarcia/projects/gnomonic/projection/logging_config.py ###
### /Users/robinsongarcia/projects/gnomonic/projection/logging_config.py ###

"""
Logging configuration for the Gnomonic Projection module.
"""

import logging
import sys

def setup_logging():
    """
    Set up logging configuration.
    """
    logger = logging.getLogger('gnomonic_projection')
    logger.setLevel(logging.DEBUG)  # Set to DEBUG to capture all levels of logs

    # Create handlers
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.INFO)  # Set to INFO for console output

    file_handler = logging.FileHandler('gnomonic_projection.log')
    file_handler.setLevel(logging.DEBUG)  # Detailed logs in file

    # Create formatters and add them to handlers
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    console_handler.setFormatter(formatter)
    file_handler.setFormatter(formatter)

    # Add handlers to the logger
    if not logger.hasHandlers():
        logger.addHandler(console_handler)
        logger.addHandler(file_handler)

    return logger

### /Users/robinsongarcia/projects/gnomonic/projection/mercator/__init__.py ###
from .config import MercatorConfig
from .grid import MercatorGridGeneration
from .strategy import MercatorProjectionStrategy

__all__ = [
    "MercatorConfig",
    "MercatorGridGeneration",
    "MercatorProjectionStrategy",
]

### /Users/robinsongarcia/projects/gnomonic/projection/mercator/config.py ###
from typing import Any, Optional
from pydantic import BaseModel, Field
import cv2
import logging
from ..exceptions import ConfigurationError

logger = logging.getLogger('projection.mercator.config')

class MercatorConfigModel(BaseModel):
    R: float = Field(1, description="Radius of the sphere (in kilometers).")
    lon_min: float = Field(-180.0, description="Minimum longitude.")
    lon_max: float = Field(180.0, description="Maximum longitude.")
    lat_min: float = Field(-85.0, description="Minimum latitude (restricted for Mercator).")
    lat_max: float = Field(85.0, description="Maximum latitude (restricted for Mercator).")
    x_points: int = Field(1024, description="Number of points along the x-axis.")
    y_points: int = Field(512, description="Number of points along the y-axis.")
    fov_deg: float = Field(90.0, description="Field of view in degrees")
    interpolation: Optional[int] = Field(default=cv2.INTER_LINEAR, description="Interpolation method for OpenCV remap")
    borderMode: Optional[int] = Field(default=cv2.BORDER_CONSTANT, description="Border mode for OpenCV remap")
    borderValue: Optional[Any] = Field(default=0, description="Border value for OpenCV remap")

class MercatorConfig:
    """
    Configuration class for Mercator projection.
    """
    def __init__(self, **kwargs):
        logger.debug("Initializing MercatorConfig with parameters: %s", kwargs)
        try:
            self.config = MercatorConfigModel(**kwargs)
        except Exception as e:
            logger.error("Failed to initialize MercatorConfig.")
            raise ValueError(f"Configuration error: {e}")

    def __repr__(self):
        return f"MercatorConfig({self.config.dict()})"
    

    def update(self, **kwargs: Any) -> None:
        logger.debug(f"Updating MercatorConfig with parameters: {kwargs}")
        try:
            updated_config = self.config.copy(update=kwargs)
            self.config = updated_config
            logger.info("MercatorConfig updated successfully.")
        except Exception as e:
            error_msg = f"Failed to update MercatorConfig: {e}"
            logger.exception(error_msg)
            raise ConfigurationError(error_msg) from e

    def __getattr__(self, item: str) -> Any:
        logger.debug(f"Accessing MercatorConfig attribute '{item}'.")
        try:
            return getattr(self.config, item)
        except AttributeError:
            error_msg = f"'MercatorConfig' object has no attribute '{item}'"
            logger.error(error_msg)
            raise AttributeError(error_msg) from None


### /Users/robinsongarcia/projects/gnomonic/projection/mercator/grid.py ###
from ..base.grid import BaseGridGeneration
import numpy as np
import logging

logger = logging.getLogger('projection.mercator.grid')

class MercatorGridGeneration(BaseGridGeneration):
    """
    Grid generation for Mercator projection.
    """

    def __init__(self, config):
        self.config = config

    def _create_grid(self, direction: str):
        if direction == 'forward':
            lon = np.linspace(
                self.config.config.lon_min, self.config.config.lon_max, self.config.config.x_points
            )
            lat = np.linspace(
                self.config.config.lat_min, self.config.config.lat_max, self.config.config.y_points
            )
            grid_lon, grid_lat = np.meshgrid(lon, lat)
            return grid_lon, grid_lat
        elif direction == 'backward':
            x = np.linspace(-1, 1, self.config.config.x_points)
            y = np.linspace(-1, 1, self.config.config.y_points)
            return np.meshgrid(x, y)
        else:
            raise ValueError("Invalid direction. Must be 'forward' or 'backward'.")

### /Users/robinsongarcia/projects/gnomonic/projection/mercator/strategy.py ###
from ..base.strategy import BaseProjectionStrategy
import numpy as np
import logging

logger = logging.getLogger('projection.mercator.strategy')

class MercatorProjectionStrategy(BaseProjectionStrategy):
    """
    Projection strategy for Mercator projection.
    """

    def __init__(self, config):
        self.config = config

    def forward(self, lon: np.ndarray, lat: np.ndarray):
        """
        Convert geographic coordinates to Cartesian coordinates.
        """
        x = self.config.config.R * np.radians(lon)
        y = self.config.config.R * np.log(np.tan(np.pi / 4 + np.radians(lat) / 2))
        return x, y

    def backward(self, x: np.ndarray, y: np.ndarray):
        """
        Convert Cartesian coordinates to geographic coordinates.
        """
        lon = np.degrees(x / self.config.config.R)
        lat = np.degrees(2 * np.arctan(np.exp(y / self.config.config.R)) - np.pi / 2)
        mask = (lon >= self.config.config.lon_min) & (lon <= self.config.config.lon_max) & \
               (lat >= self.config.config.lat_min) & (lat <= self.config.config.lat_max)
        return lon, lat, mask

### /Users/robinsongarcia/projects/gnomonic/projection/mercator/transform.py ###
from typing import Tuple, Any
import numpy as np
import logging
from ..exceptions import TransformationError

logger = logging.getLogger('projection.mercator.transform')

class MercatorTransformer:
    """
    Transformation logic for Mercator projection.
    """
    def __init__(self, config):
        """
        Initialize the GnomonicTransformer with the given configuration.

        Args:
            config: Configuration object with necessary parameters.
        """
        self.config = config  # Store the configuration object for use in transformations
        
    @staticmethod
    def latlon_to_image_coords(
        lat: np.ndarray, 
        lon: np.ndarray, 
        config: Any, 
        shape: Tuple[int, int]
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Convert latitude and longitude to Mercator image coordinates.

        Args:
            lat (np.ndarray): Latitude values.
            lon (np.ndarray): Longitude values.
            config (Any): Configuration object containing grid parameters.
            shape (Tuple[int, int]): Shape of the target image (height, width).

        Returns:
            Tuple[np.ndarray, np.ndarray]: X and Y coordinates in image space.

        Raises:
            TransformationError: If input arrays are invalid or computation fails.
        """
        logger.debug("Transforming lat/lon to Mercator image coordinates.")
        try:
            H, W = shape
            map_x = (lon - config.lon_min) / (config.lon_max - config.lon_min) * (W - 1)

            lat_rad = np.radians(lat)
            lat_min_rad = np.radians(config.lat_min)
            lat_max_rad = np.radians(config.lat_max)
            map_y = (
                np.log(np.tan(np.pi / 4 + lat_rad / 2)) -
                np.log(np.tan(np.pi / 4 + lat_min_rad / 2))
            ) / (
                np.log(np.tan(np.pi / 4 + lat_max_rad / 2)) -
                np.log(np.tan(np.pi / 4 + lat_min_rad / 2))
            ) * (H - 1)

            return map_x, map_y
        except Exception as e:
            logger.exception("Failed to transform coordinates for Mercator projection.")
            raise TransformationError(f"Mercator transformation failed: {e}")

    @staticmethod
    def xy_to_image_coords(
        x: np.ndarray, 
        y: np.ndarray, 
        config: Any
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Transform XY grid coordinates to Mercator image coordinates.

        Args:
            x (np.ndarray): X grid coordinates.
            y (np.ndarray): Y grid coordinates.
            config (Any): Configuration object.

        Returns:
            Tuple[np.ndarray, np.ndarray]: Image coordinates.
        """
        raise NotImplementedError("Mercator backward transformation is not required.")

### /Users/robinsongarcia/projects/gnomonic/projection/processor.py ###
### /Users/robinsongarcia/projects/gnomonic/projection/processor.py ###

from typing import Any, Optional, Tuple
from .base.config import BaseProjectionConfig
from .base.transform import CoordinateTransformer
from .exceptions import ProcessingError, InterpolationError, GridGenerationError, TransformationError
import logging
import cv2
import numpy as np

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.processor')


class ProjectionProcessor:
    """
    Processor for handling forward and backward projections using the provided configuration.
    """
    def __init__(self, config: BaseProjectionConfig) -> None:
        """
        Initialize the ProjectionProcessor with a given configuration.

        Args:
            config (BaseProjectionConfig): The projection configuration.

        Raises:
            TypeError: If 'config' is not an instance of BaseProjectionConfig.
            ProcessingError: If initialization of components fails.
        """
        logger.debug("Initializing ProjectionProcessor.")
        if not isinstance(config, BaseProjectionConfig):
            error_msg = f"config must be an instance of BaseProjectionConfig, got {type(config)} instead."
            logger.error(error_msg)
            raise TypeError(error_msg)

        self.config: BaseProjectionConfig = config
        try:
            self.projection = config.create_projection()
            self.grid_generation = config.create_grid_generation()
            self.interpolation = config.create_interpolation()
            self.transformer = config.create_transformer()  # Initialize transformer
            logger.info("ProjectionProcessor components initialized successfully.")
        except Exception as e:
            error_msg = f"Failed to initialize ProjectionProcessor components: {e}"
            logger.exception(error_msg)
            raise ProcessingError(error_msg) from e

    def forward(self, img: np.ndarray, **kwargs: Any) -> np.ndarray:
        """
        Forward projection of an image.

        Args:
            img (np.ndarray): The input equirectangular image.
            **kwargs (Any): Additional parameters to override projection configuration.

        Returns:
            np.ndarray: Projected rectilinear image.

        Raises:
            ValueError: If the input image is not a valid NumPy array.
            GridGenerationError: If grid generation fails.
            ProcessingError: If forward projection fails.
            TransformationError: If coordinate transformation fails.
            InterpolationError: If interpolation fails.
        """
        logger.debug("Starting forward projection.")
        if not isinstance(img, np.ndarray):
            error_msg = "Input image must be a NumPy ndarray."
            logger.error(error_msg)
            raise ValueError(error_msg)

        try:
            self.config.update(**kwargs)
            logger.debug(f"Configuration updated with parameters: {kwargs}")

            x_grid, y_grid = self.grid_generation.create_grid('forward')
            logger.debug("Forward grid generated successfully.")

            lat, lon = self.projection.forward(x_grid, y_grid)
            logger.debug("Forward projection computed successfully.")

            map_x, map_y = self.transformer.latlon_to_image_coords(
                lat, lon, self.grid_generation.config, img.shape
            )
            logger.debug("Coordinates transformed to image space successfully.")

            projected_img = self.interpolation.interpolate(img, map_x, map_y)
            logger.info("Forward projection completed successfully.")
            return projected_img

        except (GridGenerationError, ProcessingError, TransformationError, InterpolationError) as e:
            logger.error(f"Forward projection failed: {e}")
            raise
        except Exception as e:
            logger.exception("Unexpected error during forward projection.")
            raise ProcessingError(f"Unexpected error during forward projection: {e}")

    def backward(self, rect_img: np.ndarray, **kwargs: Any) -> np.ndarray:
        """
        Backward projection of a rectilinear image to equirectangular.

        Args:
            rect_img (np.ndarray): The rectilinear image.
            **kwargs (Any): Additional parameters to override projection configuration.

        Returns:
            np.ndarray: Back-projected equirectangular image.

        Raises:
            ValueError: If the input image is not a valid NumPy array.
            GridGenerationError: If grid generation fails.
            ProcessingError: If backward projection fails.
            TransformationError: If coordinate transformation fails.
            InterpolationError: If interpolation fails.
        """
        logger.debug("Starting backward projection.")
        if not isinstance(rect_img, np.ndarray):
            error_msg = "Rectilinear image must be a NumPy ndarray."
            logger.error(error_msg)
            raise ValueError(error_msg)

        try:
            self.config.update(**kwargs)
            logger.debug(f"Configuration updated with parameters: {kwargs}")

            lon_grid, lat_grid = self.grid_generation.create_grid('backward')
            logger.debug("Backward grid generated successfully.")

            x, y, mask = self.projection.backward(lat_grid, lon_grid)
            logger.debug("Backward projection computed successfully.")

            map_x, map_y = self.transformer.xy_to_image_coords(x, y, self.grid_generation.config)
            logger.debug("Grid coordinates transformed to image space successfully.")

            back_projected_img = self.interpolation.interpolate(
                rect_img, map_x, map_y, mask if kwargs.get("return_mask", False) else None
            )
            logger.info("Backward projection completed successfully.")
            return back_projected_img

        except (GridGenerationError, ProcessingError, TransformationError, InterpolationError) as e:
            logger.error(f"Backward projection failed: {e}")
            raise
        except Exception as e:
            logger.exception("Unexpected error during backward projection.")
            raise ProcessingError(f"Unexpected error during backward projection: {e}")

### /Users/robinsongarcia/projects/gnomonic/projection/registry.py ###
from typing import Any, Dict, Optional, Type, Union
from .base.config import BaseProjectionConfig
from .processor import ProjectionProcessor
from .exceptions import RegistrationError
import logging

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.registry')


class ProjectionRegistry:
    """
    Registry for managing projection configurations and their components.
    """
    _registry: Dict[str, Dict[str, Type[Any]]] = {}

    @classmethod
    def register(cls, name: str, components: Dict[str, Type[Any]]) -> None:
        """
        Register a projection with its required components.

        Args:
            name (str): Name of the projection (e.g., 'gnomonic').
            components (Dict[str, Type[Any]]): A dictionary containing:
                - 'config': Configuration class
                - 'grid_generation': Grid generation class
                - 'projection_strategy': Projection strategy class
                - 'interpolation' (optional): Interpolation class
                - 'transformer': Transformation class (optional)

        Raises:
            RegistrationError: If required components are missing or invalid.
        """
        logger.debug(f"Attempting to register projection '{name}' with components: {list(components.keys())}")
        required_keys = {"config", "grid_generation", "projection_strategy"}
        missing_keys = required_keys - components.keys()
        if missing_keys:
            error_msg = f"Components must include {required_keys}. Missing keys: {missing_keys}"
            logger.error(error_msg)
            raise RegistrationError(error_msg)

        # Optional 'interpolation' and 'transformer' components
        for key in ["interpolation", "transformer"]:
            if key in components:
                if not isinstance(components[key], type):
                    error_msg = f"'{key}' component must be a class type."
                    logger.error(error_msg)
                    raise RegistrationError(error_msg)
                logger.debug(f"'{key}' component validated as a class type.")

        cls._registry[name] = components
        logger.info(f"Projection '{name}' registered successfully.")

    @classmethod
    def get_projection(
        cls, 
        name: str, 
        return_processor: bool = False, 
        **kwargs: Any
    ) -> Union[BaseProjectionConfig, ProjectionProcessor]:
        """
        Retrieve a configured projection by name.

        Args:
            name (str): Name of the projection to retrieve.
            return_processor (bool): Whether to return the processor instead of the config.
            **kwargs (Any): Configuration parameters to override defaults.

        Returns:
            Union[BaseProjectionConfig, ProjectionProcessor]: Depending on `return_processor`.

        Raises:
            RegistrationError: If the projection name is not found or components are missing.
            ProcessingError: If instantiation of configuration fails.
        """
        logger.debug(f"Retrieving projection '{name}' with override parameters: {kwargs}")
        if name not in cls._registry:
            error_msg = f"Projection '{name}' not found in the registry."
            logger.error(error_msg)
            raise RegistrationError(error_msg)

        # Retrieve components
        components = cls._registry[name]
        try:
            ConfigClass = components["config"]
            GridGenerationClass = components["grid_generation"]
            ProjectionStrategyClass = components["projection_strategy"]
            InterpolationClass = components.get("interpolation", None)
            TransformerClass = components.get("transformer", None)
            logger.debug(f"Components for projection '{name}': {list(components.keys())}")
        except KeyError as e:
            error_msg = f"Missing component in the registry: {e}"
            logger.error(error_msg)
            raise RegistrationError(error_msg) from e

        # Instantiate the configuration object
        try:
            config_instance = ConfigClass(**kwargs)
            logger.debug(f"Configuration instance for projection '{name}' created successfully.")
        except Exception as e:
            error_msg = f"Failed to instantiate config class '{ConfigClass.__name__}': {e}"
            logger.exception(error_msg)
            raise RegistrationError(error_msg) from e

        # Create a BaseProjectionConfig and attach the necessary methods
        base_config = BaseProjectionConfig(config_instance)
        base_config.create_projection = lambda: ProjectionStrategyClass(config_instance)
        base_config.create_grid_generation = lambda: GridGenerationClass(config_instance)
        if InterpolationClass:
            base_config.create_interpolation = lambda: InterpolationClass(config_instance)
        if TransformerClass:
            base_config.create_transformer = lambda: TransformerClass(config_instance)
        if return_processor:
            logger.debug(f"Returning ProjectionProcessor for projection '{name}'.")
            return ProjectionProcessor(base_config)

        logger.debug(f"Returning BaseProjectionConfig for projection '{name}'.")
        return base_config

    @classmethod
    def list_projections(cls) -> list:
        """
        List all registered projections.

        Returns:
            list: A list of projection names.
        """
        logger.debug("Listing all registered projections.")
        projections = list(cls._registry.keys())
        logger.info(f"Registered projections: {projections}")
        return projections

