### /Users/robinsongarcia/projects/gnomonic/projection//__init__.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/__init__.py

"""
Gnomonic Projection Package

This package provides functionalities for gnomonic projections,
including registry management and default projection registration.
"""

from .registry import ProjectionRegistry
from .default_projections import register_default_projections
from .logging_config import setup_logging

# Set up logging
logger = setup_logging()
logger.info("Initializing Gnomonic Projection Package")

# Automatically register default projections
try:
    register_default_projections()
    logger.info("Default projections registered successfully.")
except Exception as e:
    logger.exception("Failed to register default projections.")
    raise RuntimeError("Failed to register default projections.") from e

__all__ = ["ProjectionRegistry"]

### /Users/robinsongarcia/projects/gnomonic/projection//base/__init__.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/base/__init__.py

"""
Base module for gnomonic projection components.

This module includes base classes for projection configuration,
strategy, grid generation, interpolation, and coordinate transformations.
"""

from .config import BaseProjectionConfig
from .strategy import BaseProjectionStrategy
from .grid import BaseGridGeneration
from .interpolation import BaseInterpolation
from .transform import BaseCoordinateTransformer
from ..exceptions import (
    ProjectionError,
    ConfigurationError,
    RegistrationError,
    ProcessingError,
    GridGenerationError,
    TransformationError,
    InterpolationError,
)

__all__ = [
    "BaseProjectionConfig",
    "BaseProjectionStrategy",
    "BaseGridGeneration",
    "BaseInterpolation",
    "BaseCoordinateTransformer",
    "ProjectionError",
    "ConfigurationError",
    "RegistrationError",
    "ProcessingError",
    "GridGenerationError",
    "TransformationError",
    "InterpolationError",
]

### /Users/robinsongarcia/projects/gnomonic/projection//base/config.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/base/config.py

from typing import Any, Dict, Optional
from pydantic import BaseModel, Field, validator
from ..base.interpolation import BaseInterpolation
from ..exceptions import ConfigurationError
import logging

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.base.config')

class BaseProjectionConfigModel(BaseModel):
    """
    Pydantic model holding basic projection configuration parameters.

    Attributes:
        interpolation (Optional[int]): Interpolation method for OpenCV remap.
        borderMode (Optional[int]): Border mode for OpenCV remap.
        borderValue (Optional[Any]): Border value for OpenCV remap.
    """
    interpolation: Optional[int] = Field(default=0, description="Interpolation method for OpenCV remap")
    borderMode: Optional[int] = Field(default=0, description="Border mode for OpenCV remap")
    borderValue: Optional[Any] = Field(default=0, description="Border value for OpenCV remap")

    class Config:
        arbitrary_types_allowed = True

class BaseProjectionConfig:
    """
    Base class for projections, allowing dynamic initialization with configuration objects.
    Utilizes Pydantic for configuration validation and management.
    """

    def __init__(self, config_object: Any) -> None:
        """
        Initialize the projection configuration.

        Args:
            config_object (Any): An object (e.g., GnomonicConfig) containing configuration parameters.

        Raises:
            ConfigurationError: If the configuration object does not have a 'config' attribute.
        """
        logger.debug("Initializing BaseProjectionConfig.")
        if not hasattr(config_object, "config"):
            error_msg = "Configuration object must have a 'config' attribute."
            logger.error(error_msg)
            raise ConfigurationError(error_msg)
        self.config_object: Any = config_object
        try:
            self.params: BaseProjectionConfigModel = config_object.config
            logger.debug("Configuration parameters loaded successfully.")
        except Exception as e:
            error_msg = f"Failed to load configuration parameters: {e}"
            logger.exception(error_msg)
            raise ConfigurationError(error_msg) from e
        self.extra_params: Dict[str, Any] = {}

    def create_projection(self) -> Any:
        """
        Placeholder for creating a projection object.
        Subclasses or dynamic creation logic should override this method.

        Raises:
            NotImplementedError: If the method is not overridden by subclasses.
        """
        logger.debug("create_projection method called.")
        raise NotImplementedError("Subclasses or configuration must implement create_projection.")

    def create_grid_generation(self) -> Any:
        """
        Placeholder for creating a grid generation object.
        Subclasses or dynamic creation logic should override this method.

        Raises:
            NotImplementedError: If the method is not overridden by subclasses.
        """
        logger.debug("create_grid_generation method called.")
        raise NotImplementedError("Subclasses or configuration must implement create_grid_generation.")

    def create_interpolation(self) -> BaseInterpolation:
        """
        Create an interpolation object using the configuration.

        Returns:
            BaseInterpolation: The interpolation object.
        """
        logger.debug("Creating interpolation object.")
        return BaseInterpolation(self)

    def create_transformer(self) -> Any:
        """
        Placeholder for creating a transformer object.

        Raises:
            NotImplementedError: If the method is not overridden by subclasses.
        """
        logger.debug("create_transformer method called.")
        raise NotImplementedError("Subclasses or configuration must implement create_transformer.")

    def update(self, **kwargs: Any) -> None:
        """
        Update configuration parameters dynamically.

        Args:
            **kwargs (Any): Parameters to update in the configuration.
        """
        logger.debug(f"Updating configuration with parameters: {kwargs}")
        for key, value in kwargs.items():
            if key in self.params.__fields__:
                try:
                    setattr(self.params, key, value)
                    logger.debug(f"Parameter '{key}' updated to {value}.")
                except Exception as e:
                    error_msg = f"Failed to update parameter '{key}': {e}"
                    logger.exception(error_msg)
                    raise ConfigurationError(error_msg) from e
            else:
                self.extra_params[key] = value
                logger.debug(f"Extra parameter '{key}' set to {value}.")

    def __getattr__(self, item: str) -> Any:
        """
        Access configuration parameters as attributes.

        Args:
            item (str): Parameter name.

        Returns:
            Any: The value of the parameter if it exists.

        Raises:
            AttributeError: If the parameter does not exist.
        """
        logger.debug(f"Accessing attribute '{item}'.")
        if hasattr(self.config_object, item):
            return getattr(self.config_object, item)
        if item in self.extra_params:
            return self.extra_params[item]
        error_msg = f"'{type(self).__name__}' object has no attribute '{item}'"
        logger.error(error_msg)
        raise AttributeError(error_msg)

    def __repr__(self) -> str:
        """
        String representation of the configuration.

        Returns:
            str: Human-readable string of configuration parameters.
        """
        return f"BaseProjectionConfig(params={self.params.dict()}, extra_params={self.extra_params})"

### /Users/robinsongarcia/projects/gnomonic/projection//base/grid.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/base/grid.py

from typing import Any, Tuple
import numpy as np
import logging
from ..exceptions import GridGenerationError, ProcessingError

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.base.grid')

class BaseGridGeneration:
    """
    Base class for grid generation in projections.
    """

    def __init__(self, config):
        """
        Initialize the BaseGridGeneration with the given configuration.

        Args:
            config (Any): Projection configuration object.
        """
        logger.debug("Initializing BaseGridGeneration.")
        self.config = config

    def projection_grid(self) -> Tuple[np.ndarray, np.ndarray]:
        """
        Placeholder method to generate the grid for forward projection.

        Returns:
            Tuple[np.ndarray, np.ndarray]: The X and Y coordinate grids.

        Raises:
            NotImplementedError: If the subclass does not implement this method.
        """
        logger.debug("projection_grid method called (Base class).")
        raise NotImplementedError("Subclasses must implement _create_grid.")

### /Users/robinsongarcia/projects/gnomonic/projection//base/interpolation.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/base/interpolation.py

from typing import Any, Optional
import cv2
import numpy as np
import logging
from ..exceptions import InterpolationError

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.base.interpolation')

class BaseInterpolation:
    """
    Base class for image interpolation in projections.
    """

    def __init__(self, config: Any) -> None:
        """
        Initialize the interpolation with the given configuration.

        Args:
            config (Any): The projection configuration.

        Raises:
            TypeError: If 'config' does not have required attributes.
        """
        logger.debug("Initializing BaseInterpolation.")
        if not hasattr(config, "interpolation") or not hasattr(config, "borderMode") or not hasattr(config, "borderValue"):
            error_msg = "Config must have 'interpolation', 'borderMode', and 'borderValue' attributes."
            logger.error(error_msg)
            raise TypeError(error_msg)
        self.config: Any = config
        logger.info("BaseInterpolation initialized successfully.")

    def interpolate(
        self, 
        input_img: np.ndarray, 
        map_x: np.ndarray, 
        map_y: np.ndarray, 
        mask: Optional[np.ndarray] = None
    ) -> np.ndarray:
        """
        Perform image interpolation based on the provided mapping.

        Args:
            input_img (np.ndarray): The input image to interpolate.
            map_x (np.ndarray): The mapping for the x-coordinates.
            map_y (np.ndarray): The mapping for the y-coordinates.
            mask (Optional[np.ndarray], optional): Mask to apply to the interpolated image. Defaults to None.

        Returns:
            np.ndarray: The interpolated image.

        Raises:
            InterpolationError: If OpenCV remap fails or inputs are invalid.
        """
        logger.debug("Starting image interpolation.")
        if not isinstance(input_img, np.ndarray):
            error_msg = "input_img must be a NumPy ndarray."
            logger.error(error_msg)
            raise InterpolationError(error_msg)
        if not isinstance(map_x, np.ndarray) or not isinstance(map_y, np.ndarray):
            error_msg = "map_x and map_y must be NumPy ndarrays."
            logger.error(error_msg)
            raise InterpolationError(error_msg)

        try:
            map_x_32: np.ndarray = map_x.astype(np.float32)
            map_y_32: np.ndarray = map_y.astype(np.float32)
            logger.debug("map_x and map_y converted to float32 successfully.")
        except Exception as e:
            error_msg = f"Failed to convert map_x or map_y to float32: {e}"
            logger.exception(error_msg)
            raise InterpolationError(error_msg) from e

        try:
            result: np.ndarray = cv2.remap(
                input_img, map_x_32, map_y_32,
                interpolation=self.config.interpolation,
                borderMode=self.config.borderMode,
                borderValue=self.config.borderValue
            )
            logger.debug("OpenCV remap executed successfully.")
        except cv2.error as e:
            error_msg = f"OpenCV remap failed: {e}"
            logger.exception(error_msg)
            raise InterpolationError(error_msg) from e

        if mask is not None:
            logger.debug("Applying mask to interpolated image.")
            if not isinstance(mask, np.ndarray):
                error_msg = "mask must be a NumPy ndarray if provided."
                logger.error(error_msg)
                raise InterpolationError(error_msg)
            if mask.shape != result.shape[:2]:
                error_msg = "mask shape must match the first two dimensions of the result."
                logger.error(error_msg)
                raise InterpolationError(error_msg)
            result *= mask[:, :, None]
            logger.debug("Mask applied successfully.")

        logger.info("Image interpolation completed successfully.")
        return result

### /Users/robinsongarcia/projects/gnomonic/projection//base/registry.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/base/registry.py

from typing import Any, Dict, Optional, Type, Union
import logging

logger = logging.getLogger('gnomonic_projection.registry')

class RegistryBase(type):
    """
    Metaclass to automatically register classes in a central REGISTRY dictionary.
    """

    REGISTRY = {}

    def __new__(cls, name, bases, attrs):
        """
        Create a new class and register it in the REGISTRY.
        """
        new_cls = type.__new__(cls, name, bases, attrs)
        cls.REGISTRY[new_cls.__name__] = new_cls
        return new_cls

    @classmethod
    def get_registry(cls):
        """
        Retrieve the dictionary of all registered classes.
        
        Returns:
            dict: Copy of the class registry.
        """
        return dict(cls.REGISTRY)

class BaseRegisteredClass(metaclass=RegistryBase):
    """
    Base class that uses the RegistryBase metaclass for automatic registration.
    """
    pass

### /Users/robinsongarcia/projects/gnomonic/projection//base/strategy.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/base/strategy.py

from typing import Any, Tuple
import numpy as np
import logging
from ..exceptions import ProcessingError

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.base.strategy')

class BaseProjectionStrategy:
    """
    Base class for projection strategies.
    """

    @classmethod
    def from_spherical_to_projection(self, x: np.ndarray, y: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        Perform forward projection from grid coordinates to latitude and longitude.

        Args:
            x (np.ndarray): X-coordinates in the grid.
            y (np.ndarray): Y-coordinates in the grid.

        Returns:
            Tuple[np.ndarray, np.ndarray]: Latitude and longitude arrays.

        Raises:
            ProcessingError: If inputs are not valid NumPy arrays or method is not overridden.
        """
        logger.debug("Starting forward projection in BaseProjectionStrategy.")
        if not isinstance(x, np.ndarray) or not isinstance(y, np.ndarray):
            error_msg = "x and y must be NumPy ndarrays."
            logger.error(error_msg)
            raise ProcessingError(error_msg)
        logger.debug("Forward projection inputs are valid.")
        raise NotImplementedError("Subclasses must implement forward.")

    @classmethod
    def from_projection_to_spherical(self, lat: np.ndarray, lon: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Perform backward projection from latitude and longitude to grid coordinates.

        Args:
            lat (np.ndarray): Latitude values.
            lon (np.ndarray): Longitude values.

        Returns:
            Tuple[np.ndarray, np.ndarray, np.ndarray]: X and Y coordinates in the grid, and a mask array.

        Raises:
            ProcessingError: If inputs are not valid NumPy arrays or method is not overridden.
        """
        logger.debug("Starting backward projection in BaseProjectionStrategy.")
        if not isinstance(lat, np.ndarray) or not isinstance(lon, np.ndarray):
            error_msg = "lat and lon must be NumPy ndarrays."
            logger.error(error_msg)
            raise ProcessingError(error_msg)
        logger.debug("Backward projection inputs are valid.")
        raise NotImplementedError("Subclasses must implement backward.")

### /Users/robinsongarcia/projects/gnomonic/projection//base/transform.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/base/transform.py

from typing import Any, Tuple
import numpy as np
import logging
from ..exceptions import TransformationError, ConfigurationError

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.base.transform')

class BaseCoordinateTransformer:
    """
    Utility class for transforming coordinates between different systems.
    """

    def __init__(self, config) -> None:
        """
        Initialize the BaseCoordinateTransformer with a given configuration.

        Args:
            config: The configuration containing necessary projection parameters.
        """
        logger.debug("Initializing BaseCoordinateTransformer.")
        self.config = config

    @classmethod
    def spherical_to_image_coords(
        lat: np.ndarray, 
        lon: np.ndarray, 
        config: Any, 
        shape: Tuple[int, int, ...]
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Placeholder method for converting spherical coordinates to image coordinates.

        Raises:
            NotImplementedError: This method must be implemented by a subclass.
        """
        raise NotImplementedError("Subclasses must implement forward.")

    @staticmethod
    def projection_to_image_coords(
        x: np.ndarray, 
        y: np.ndarray, 
        config: Any
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Placeholder method for converting projection coordinates to image coordinates.

        Raises:
            NotImplementedError: This method must be implemented by a subclass.
        """
        raise NotImplementedError("Subclasses must implement forward.")

### /Users/robinsongarcia/projects/gnomonic/projection//default_projections.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/default_projections.py

from .registry import ProjectionRegistry

from .gnomonic.config import GnomonicConfig
from .gnomonic.grid import GnomonicGridGeneration
from .gnomonic.strategy import GnomonicProjectionStrategy
from .gnomonic.transform import GnomonicTransformer  # Updated to per-projection transformer

from .mercator.config import MercatorConfig
from .mercator.grid import MercatorGridGeneration
from .mercator.strategy import MercatorProjectionStrategy
from .mercator.transform import MercatorTransformer  # Updated to per-projection transformer

from .base.interpolation import BaseInterpolation
from .exceptions import RegistrationError
import logging

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.default_projections')

def register_default_projections():
    """
    Register default projections with their components.

    Raises:
        RegistrationError: If registration of any default projection fails.
    """
    logger.debug("Registering default projections.")
    try:
        # Register Gnomonic projection
        ProjectionRegistry.register("gnomonic", {
            "config": GnomonicConfig,
            "grid_generation": GnomonicGridGeneration,
            "projection_strategy": GnomonicProjectionStrategy,
            "interpolation": BaseInterpolation,
            "transformer": GnomonicTransformer,  # Updated to GnomonicTransformer
        })
        logger.info("Default projection 'gnomonic' registered successfully.")

        # Register Mercator projection
        ProjectionRegistry.register("mercator", {
            "config": MercatorConfig,
            "grid_generation": MercatorGridGeneration,
            "projection_strategy": MercatorProjectionStrategy,
            "interpolation": BaseInterpolation,
            "transformer": MercatorTransformer,  # Updated to MercatorTransformer
        })


        logger.info("Default projection 'mercator' registered successfully.")

    except RegistrationError as e:
        logger.exception("Failed to register default projections.")
        raise RegistrationError(f"Failed to register default projections: {e}") from e
    except Exception as e:
        logger.exception("An unexpected error occurred while registering default projections.")
        raise RegistrationError(f"An unexpected error occurred: {e}") from e

    logger.debug("All default projections registered.")

### /Users/robinsongarcia/projects/gnomonic/projection//exceptions.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/exceptions.py

"""
Custom exception classes for the Gnomonic Projection module.
"""

class ProjectionError(Exception):
    """Base exception for projection-related errors."""
    pass

class ConfigurationError(ProjectionError):
    """Exception raised for configuration-related issues."""
    pass

class RegistrationError(ProjectionError):
    """Exception raised during projection registration."""
    pass

class ProcessingError(ProjectionError):
    """Exception raised during projection processing."""
    pass

class GridGenerationError(ProjectionError):
    """Exception raised during grid generation."""
    pass

class TransformationError(ProjectionError):
    """Exception raised during coordinate transformations."""
    pass

class InterpolationError(ProjectionError):
    """Exception raised during image interpolation."""
    pass

### /Users/robinsongarcia/projects/gnomonic/projection//gnomonic/__init__.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/gnomonic/__init__.py

"""
Gnomonic Projection Module

This module provides specific implementations for Gnomonic projections,
including configuration, projection strategies, and grid generation.

## Mathematical Foundation

The Gnomonic projection transforms points on the surface of a sphere (e.g., Earth)
onto a plane using a projection point located at the center of the sphere.
This projection is based on the principles of spherical trigonometry and can be
derived using the following key equations:

1. **Projection Equations:** (See inline formulas in the docstring)

2. **Special Cases:** 
   Polar Gnomonic Projection examples and usage.

The Gnomonic projection is particularly useful for mapping great circles as straight lines,
which is advantageous in navigation and aeronautics.

## Projection Processes

1. **Forward Projection:** 
   Maps points from an equirectangular (input) image to the Gnomonic projection plane.

2. **Backward Projection:**
   Maps points from the Gnomonic projection plane back to an equirectangular (output) image.

## Usage

See the example usage in the docstring below.
"""

import logging

from .config import GnomonicConfig
from .strategy import GnomonicProjectionStrategy
from .grid import GnomonicGridGeneration
from .transform import GnomonicTransformer
from ..logging_config import setup_logging

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.gnomonic')

def initialize_gnomonic_module():
    """
    Initialize the Gnomonic Projection module.

    This initialization sets up any module-specific configurations or prerequisites.
    Currently, it primarily logs the initialization status.
    """
    logger.debug("Initializing Gnomonic Projection Module.")
    # Any module-specific initialization can be done here
    logger.info("Gnomonic Projection Module initialized successfully.")

# Call the initialization function upon import
initialize_gnomonic_module()

__all__ = [
    "GnomonicConfig",
    "GnomonicProjectionStrategy",
    "GnomonicGridGeneration",
    "GnomonicTransformer"
]

### /Users/robinsongarcia/projects/gnomonic/projection//gnomonic/config.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/gnomonic/config.py

from typing import Any, Optional
from pydantic import BaseModel, Field, validator
import cv2
import logging
from ..exceptions import ConfigurationError

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.gnomonic.config')

class GnomonicConfigModel(BaseModel):
    """
    Pydantic model for Gnomonic projection configuration.

    Attributes include radius of the Earth, center latitude and longitude,
    field of view, grid resolutions, bounding box for lat/lon, and interpolation
    parameters.
    """
    R: float = Field(1.0, description="Radius of the sphere (e.g., Earth) in consistent units.")
    phi1_deg: float = Field(0.0, description="Latitude of the projection center in degrees.")
    lam0_deg: float = Field(0.0, description="Longitude of the projection center in degrees.")
    fov_deg: float = Field(90.0, description="Field of view in degrees.")
    x_points: int = Field(512, description="Number of grid points in the x-direction.")
    y_points: int = Field(512, description="Number of grid points in the y-direction.")
    lon_points: int = Field(1024, description="Number of longitude points for inverse grid mapping.")
    lat_points: int = Field(512, description="Number of latitude points for inverse grid mapping.")
    lon_min: float = Field(-180.0, description="Minimum longitude in the grid (degrees).")
    lon_max: float = Field(180.0, description="Maximum longitude in the grid (degrees).")
    lat_min: float = Field(-90.0, description="Minimum latitude in the grid (degrees).")
    lat_max: float = Field(90.0, description="Maximum latitude in the grid (degrees).")
    interpolation: Optional[int] = Field(default=cv2.INTER_LINEAR, description="Interpolation method for OpenCV remap.")
    borderMode: Optional[int] = Field(default=cv2.BORDER_CONSTANT, description="Border mode for OpenCV remap.")
    borderValue: Optional[Any] = Field(default=0, description="Border value for OpenCV remap.")

    @validator('fov_deg')
    def validate_fov(cls, v):
        """
        Validate that the field of view is between 0 and 180 degrees.
        """
        if not (0 < v < 180):
            raise ValueError("Field of view (fov_deg) must be between 0 and 180 degrees.")
        return v

    class Config:
        arbitrary_types_allowed = True

class GnomonicConfig:
    """
    Configuration class for Gnomonic projections using Pydantic for validation.

    This class encapsulates all necessary parameters required to perform both forward (equirectangular to Gnomonic)
    and inverse (Gnomonic to equirectangular) projections. It ensures that configurations are validated
    and managed efficiently.
    """

    def __init__(self, **kwargs: Any) -> None:
        """
        Initialize the GnomonicConfig with provided parameters.

        Args:
            **kwargs (Any): Configuration parameters as keyword arguments.

        Raises:
            ConfigurationError: If initialization fails due to invalid parameters.
        """
        logger.debug("Initializing GnomonicConfig with parameters: %s", kwargs)
        try:
            self.config = GnomonicConfigModel(**kwargs)
            logger.info("GnomonicConfig initialized successfully.")
        except Exception as e:
            error_msg = f"Failed to initialize GnomonicConfig: {e}"
            logger.exception(error_msg)
            raise ConfigurationError(error_msg) from e

    def update(self, **kwargs: Any) -> None:
        """
        Update configuration parameters dynamically.

        Args:
            **kwargs (Any): Parameters to update in the configuration.

        Raises:
            ConfigurationError: If updating fails due to invalid parameters.
        """
        logger.debug(f"Updating GnomonicConfig with parameters: {kwargs}")
        try:
            updated_config = self.config.copy(update=kwargs)
            self.config = updated_config
            logger.info("GnomonicConfig updated successfully.")
        except Exception as e:
            error_msg = f"Failed to update GnomonicConfig: {e}"
            logger.exception(error_msg)
            raise ConfigurationError(error_msg) from e

    def __getattr__(self, item: str) -> Any:
        """
        Access configuration parameters as attributes.

        Args:
            item (str): Parameter name.

        Returns:
            Any: The value of the parameter if it exists.

        Raises:
            AttributeError: If the parameter does not exist.
        """
        logger.debug(f"Accessing GnomonicConfig attribute '{item}'.")
        try:
            return getattr(self.config, item)
        except AttributeError:
            error_msg = f"'GnomonicConfig' object has no attribute '{item}'"
            logger.error(error_msg)
            raise AttributeError(error_msg) from None

    def __repr__(self) -> str:
        """
        String representation of the configuration.

        Returns:
            str: Human-readable string of configuration parameters.
        """
        return f"GnomonicConfig({self.config.dict()})"

### /Users/robinsongarcia/projects/gnomonic/projection//gnomonic/grid.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/gnomonic/grid.py

from typing import Any, Tuple
from ..base.grid import BaseGridGeneration
from .config import GnomonicConfig
from ..exceptions import GridGenerationError
import numpy as np
import logging

logger = logging.getLogger('gnomonic_projection.gnomonic.grid')

class GnomonicGridGeneration(BaseGridGeneration):
    """
    Grid generation for the Gnomonic projection.
    """

    def projection_grid(self, delta_lat=0, delta_lon=0):
        """
        Generate the forward-projection grid (X, Y) for the Gnomonic projection.

        Returns:
            Tuple[np.ndarray, np.ndarray]: The X and Y coordinate grids for forward projection.
        """
        logger.debug("Generating Gnomonic projection grid.")
        half_fov_rad = np.deg2rad(self.config.fov_deg / 2)
        x_max = np.tan(half_fov_rad) * self.config.R
        y_max = np.tan(half_fov_rad) * self.config.R
        x_vals = np.linspace(-x_max, x_max, self.config.x_points)
        y_vals = np.linspace(-y_max, y_max, self.config.y_points)
        grid_x, grid_y = np.meshgrid(x_vals, y_vals)
        return grid_x, grid_y

    def spherical_grid(self, delta_lat=0, delta_lon=0):
        """
        Generate the (lon, lat) grid for backward projection.

        Returns:
            Tuple[np.ndarray, np.ndarray]: The longitude and latitude grids.
        """
        logger.debug("Generating Gnomonic spherical grid.")
        lon_vals = np.linspace(self.config.lon_min, self.config.lon_max, self.config.lon_points) + delta_lon
        lat_vals = np.linspace(self.config.lat_min, self.config.lat_max, self.config.lat_points) + delta_lat
        grid_lon, grid_lat = np.meshgrid(lon_vals, lat_vals)
        return grid_lon, grid_lat

### /Users/robinsongarcia/projects/gnomonic/projection//gnomonic/strategy.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/gnomonic/strategy.py

from typing import Any, Tuple
from ..base.strategy import BaseProjectionStrategy
from .config import GnomonicConfig
from ..exceptions import ProcessingError
import numpy as np
import logging

logger = logging.getLogger('gnomonic_projection.gnomonic.strategy')

class GnomonicProjectionStrategy(BaseProjectionStrategy):
    """
    Projection Strategy for Gnomonic Projection.

    This class implements the transformation logic for both forward (Equirectangular to Gnomonic)
    and inverse (Gnomonic to Equirectangular) projections based on spherical trigonometry.
    It ensures accurate mapping between geographic coordinates and planar projection coordinates.
    """

    def __init__(self, config: GnomonicConfig) -> None:
        """
        Initialize the GnomonicProjectionStrategy with the given configuration.

        Args:
            config (GnomonicConfig): The configuration object containing projection parameters.

        Raises:
            TypeError: If the config is not an instance of GnomonicConfig.
        """
        logger.debug("Initializing GnomonicProjectionStrategy.")
        if not isinstance(config, GnomonicConfig):
            error_msg = f"config must be an instance of GnomonicConfig, got {type(config)} instead."
            logger.error(error_msg)
            raise TypeError(error_msg)
        self.config: GnomonicConfig = config
        logger.info("GnomonicProjectionStrategy initialized successfully.")

    def from_projection_to_spherical(self, x: np.ndarray, y: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        Perform inverse Gnomonic projection from planar grid coordinates to geographic coordinates.

        Args:
            x (np.ndarray): X-coordinates in the planar grid.
            y (np.ndarray): Y-coordinates in the planar grid.

        Returns:
            Tuple[np.ndarray, np.ndarray]: Arrays of latitude and longitude corresponding to the input grid points.

        Raises:
            ProcessingError: If the projection computation fails.
        """
        logger.debug("Starting inverse Gnomonic projection (Planar to Geographic).")
        try:
            phi1_rad, lam0_rad = np.deg2rad([self.config.phi1_deg, self.config.lam0_deg])
            logger.debug(f"Projection center (phi1_rad, lam0_rad): ({phi1_rad}, {lam0_rad})")

            rho = np.sqrt(x**2 + y**2)
            logger.debug("Computed rho (radial distances) from grid points.")

            c = np.arctan2(rho, self.config.R)
            sin_c, cos_c = np.sin(c), np.cos(c)
            logger.debug(f"Computed auxiliary angles c, sin_c, cos_c for rho.")

            phi = np.arcsin(cos_c * np.sin(phi1_rad) - (y * sin_c * np.cos(phi1_rad)) / rho)
            logger.debug("Computed latitude (phi) for inverse projection.")

            lam = lam0_rad + np.arctan2(
                x * sin_c,
                rho * np.cos(phi1_rad) * cos_c + y * np.sin(phi1_rad) * sin_c
            )
            logger.debug("Computed longitude (lambda) for inverse projection.")

            lat = np.rad2deg(phi)
            lon = np.rad2deg(lam)
            logger.debug("Converted phi and lambda from radians to degrees.")

            logger.debug("Inverse Gnomonic projection computed successfully.")
            return lat, lon
        except Exception as e:
            error_msg = f"Failed during inverse Gnomonic projection: {e}"
            logger.exception(error_msg)
            raise ProcessingError(error_msg) from e

    def from_spherical_to_projection(self, lat: np.ndarray, lon: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Perform forward Gnomonic projection from geographic coordinates to planar grid coordinates.

        Args:
            lat (np.ndarray): Latitude values in degrees.
            lon (np.ndarray): Longitude values in degrees.

        Returns:
            Tuple[np.ndarray, np.ndarray, np.ndarray]: Arrays of X and Y planar coordinates and a mask indicating valid points.

        Raises:
            ProcessingError: If the projection computation fails.
        """
        logger.debug("Starting forward Gnomonic projection (Geographic to Planar).")
        try:
            phi1_rad, lam0_rad = np.deg2rad([self.config.phi1_deg, self.config.lam0_deg])
            logger.debug(f"Projection center (phi1_rad, lam0_rad): ({phi1_rad}, {lam0_rad})")

            phi_rad, lam_rad = np.deg2rad([lat, lon])
            logger.debug("Converted input lat/lon to radians.")

            cos_c = (
                np.sin(phi1_rad) * np.sin(phi_rad) +
                np.cos(phi1_rad) * np.cos(phi_rad) * np.cos(lam_rad - lam0_rad)
            )
            logger.debug("Computed cos_c for forward projection.")

            cos_c = np.where(cos_c == 0, 1e-10, cos_c)
            logger.debug("Adjusted cos_c to avoid division by zero.")

            x = self.config.R * np.cos(phi_rad) * np.sin(lam_rad - lam0_rad) / cos_c
            logger.debug("Computed X planar coordinates for forward projection.")

            y = self.config.R * (
                np.cos(phi1_rad) * np.sin(phi_rad) -
                np.sin(phi1_rad) * np.cos(phi_rad) * np.cos(lam_rad - lam0_rad)
            ) / cos_c
            logger.debug("Computed Y planar coordinates for forward projection.")

            mask = cos_c > 0
            logger.debug("Generated mask for valid projection points (cos_c > 0).")

            logger.debug("Forward Gnomonic projection computed successfully.")
            return x, y, mask
        except Exception as e:
            error_msg = f"Failed during forward Gnomonic projection: {e}"
            logger.exception(error_msg)
            raise ProcessingError(error_msg) from e

### /Users/robinsongarcia/projects/gnomonic/projection//gnomonic/transform.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/gnomonic/transform.py

from typing import Tuple, Any
import numpy as np
import logging
from ..exceptions import TransformationError, ConfigurationError
from ..base.transform import BaseCoordinateTransformer

# Configure logger for the transformation module
logger = logging.getLogger('gnomonic_projection.gnomonic.transform')

class GnomonicTransformer(BaseCoordinateTransformer):
    """
    Transformation Logic for Gnomonic Projection.

    The `GnomonicTransformer` class handles the conversion between geographic coordinates
    (latitude and longitude) and image coordinates on the Gnomonic projection plane.
    """

    def __init__(self, config):
        """
        Initialize the GnomonicTransformer with the given configuration.

        Args:
            config: Configuration object containing necessary projection parameters.
        """
        logger.debug("Initializing GnomonicTransformer.")
        required_attributes = [
            "lon_min",
            "lon_max",
            "lat_min",
            "lat_max",
            "fov_deg",
            "R",
            "x_points",
            "y_points"
        ]
        missing_attributes = [attr for attr in required_attributes if not hasattr(config, attr)]

        if missing_attributes:
            error_msg = f"Configuration object is missing required attributes: {', '.join(missing_attributes)}"
            logger.error(error_msg)
            raise ConfigurationError(error_msg)

        self.config = config
        logger.info("GnomonicTransformer initialized successfully.")

    def _validate_inputs(self, array: np.ndarray, name: str) -> None:
        """
        Validate input arrays to ensure they are NumPy arrays.

        Args:
            array (np.ndarray): Input array to validate.
            name (str): Name of the array for error messages.

        Raises:
            TransformationError: If the input is not a NumPy ndarray.
        """
        if not isinstance(array, np.ndarray):
            error_msg = f"{name} must be a NumPy ndarray."
            logger.error(error_msg)
            raise TransformationError(error_msg)

    def _compute_image_coords(
        self, values: np.ndarray, min_val: float, max_val: float, size: int
    ) -> np.ndarray:
        """
        Generalized method to compute normalized image coordinates.

        Args:
            values (np.ndarray): Input values to normalize (e.g., lat, lon, x, y).
            min_val (float): Minimum value for normalization.
            max_val (float): Maximum value for normalization.
            size (int): Size of the target axis.

        Returns:
            np.ndarray: Normalized image coordinates scaled to [0, size-1].
        """
        normalized = (values - min_val) / (max_val - min_val) * (size - 1)
        logger.debug(f"Computed normalized image coordinates.")
        return normalized

    def spherical_to_image_coords(
        self, lat: np.ndarray, lon: np.ndarray, shape: Tuple[int, int]
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Convert spherical coordinates (lat, lon) to image coordinates.

        Args:
            lat (np.ndarray): Array of latitude values.
            lon (np.ndarray): Array of longitude values.
            shape (Tuple[int, int]): Shape of the image (height, width).

        Returns:
            Tuple[np.ndarray, np.ndarray]: Image coordinates map_x, map_y.
        """
        logger.debug("Mapping spherical coordinates to image coordinates for Gnomonic projection.")
        H, W = shape  

        # Clamp extreme values if necessary (example only, logic unchanged)
        lon[lon>180] = 180 - lon[lon>180]
        lat[lat>90] = 90 - lat[lat>90]

        map_x = self._compute_image_coords(
            lon, self.config.lon_min, self.config.lon_max, W
        )
        map_y = self._compute_image_coords(
            lat, self.config.lat_max, self.config.lat_min, H
        )
        return map_x, map_y

    def projection_to_image_coords(
        self, x: np.ndarray, y: np.ndarray, config: Any
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Convert Gnomonic planar coordinates (x, y) to image coordinates.

        Args:
            x (np.ndarray): Planar X-coordinates.
            y (np.ndarray): Planar Y-coordinates.
            config (Any): Projection configuration object with fov_deg, R, etc.

        Returns:
            Tuple[np.ndarray, np.ndarray]: Image coordinates map_x, map_y.
        """
        logger.debug("Mapping Gnomonic planar coordinates to image coordinates.")
        half_fov_rad = np.deg2rad(config.fov_deg / 2)
        x_max = np.tan(half_fov_rad) * config.R
        y_max = np.tan(half_fov_rad) * config.R
        x_min, y_min = -x_max, -y_max

        map_x = self._compute_image_coords(x, x_min, x_max, config.x_points)
        map_y = self._compute_image_coords(y, y_max, y_min, config.y_points)

        return map_x, map_y

### /Users/robinsongarcia/projects/gnomonic/projection//logging_config.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/logging_config.py

"""
Logging configuration for the Gnomonic Projection module.
"""

import logging
import sys

def setup_logging():
    """
    Set up logging configuration.

    Returns:
        logging.Logger: Configured logger for the 'gnomonic_projection' namespace.
    """
    logger = logging.getLogger('gnomonic_projection')
    logger.setLevel(logging.DEBUG)  # Set to DEBUG to capture all levels of logs

    # Create handlers
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.INFO)  # Set to INFO for console output

    file_handler = logging.FileHandler('gnomonic_projection.log')
    file_handler.setLevel(logging.DEBUG)  # Detailed logs in file

    # Create formatters and add them to handlers
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    console_handler.setFormatter(formatter)
    file_handler.setFormatter(formatter)

    # Add handlers to the logger
    if not logger.hasHandlers():
        logger.addHandler(console_handler)
        logger.addHandler(file_handler)

    return logger

### /Users/robinsongarcia/projects/gnomonic/projection//mercator/__init__.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/mercator/__init__.py

from .config import MercatorConfig
from .grid import MercatorGridGeneration
from .strategy import MercatorProjectionStrategy

__all__ = [
    "MercatorConfig",
    "MercatorGridGeneration",
    "MercatorProjectionStrategy",
]

### /Users/robinsongarcia/projects/gnomonic/projection//mercator/config.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/mercator/config.py

from typing import Any, Optional
from pydantic import BaseModel, Field
import cv2
import logging
from ..exceptions import ConfigurationError

logger = logging.getLogger('projection.mercator.config')

class MercatorConfigModel(BaseModel):
    """
    Pydantic model for the Mercator projection.

    Attributes:
        R (float): Radius of the sphere.
        lon_min (float): Minimum longitude.
        lon_max (float): Maximum longitude.
        lat_min (float): Minimum latitude.
        lat_max (float): Maximum latitude.
        x_points (int): Number of points along the x-axis.
        y_points (int): Number of points along the y-axis.
        fov_deg (float): Field of view in degrees.
        interpolation (Optional[int]): Interpolation method for OpenCV remap.
        borderMode (Optional[int]): Border mode for OpenCV remap.
        borderValue (Optional[Any]): Border value for OpenCV remap.
    """
    R: float = Field(1., description="Radius of the sphere (in kilometers).")
    lon_min: float = Field(-180.0, description="Minimum longitude.")
    lon_max: float = Field(180.0, description="Maximum longitude.")
    lat_min: float = Field(-85.0, description="Minimum latitude (restricted for Mercator).")
    lat_max: float = Field(85.0, description="Maximum latitude (restricted for Mercator).")
    x_points: int = Field(1024, description="Number of points along the x-axis.")
    y_points: int = Field(512, description="Number of points along the y-axis.")
    fov_deg: float = Field(90.0, description="Field of view in degrees")
    interpolation: Optional[int] = Field(default=cv2.INTER_LINEAR, description="Interpolation method for OpenCV remap")
    borderMode: Optional[int] = Field(default=cv2.BORDER_CONSTANT, description="Border mode for OpenCV remap")
    borderValue: Optional[Any] = Field(default=0, description="Border value for OpenCV remap")

class MercatorConfig:
    """
    Configuration class for Mercator projection.
    """

    def __init__(self, **kwargs):
        """
        Initialize the MercatorConfig with specified parameters.

        Args:
            **kwargs: Arbitrary keyword arguments for config parameters.

        Raises:
            ValueError: If initialization fails due to invalid configuration.
        """
        logger.debug("Initializing MercatorConfig with parameters: %s", kwargs)
        try:
            self.config = MercatorConfigModel(**kwargs)
        except Exception as e:
            logger.error("Failed to initialize MercatorConfig.")
            raise ValueError(f"Configuration error: {e}")

    def __repr__(self):
        """
        Return a string representation of the MercatorConfig.

        Returns:
            str: Stringified config dictionary.
        """
        return f"MercatorConfig({self.config.dict()})"

    def update(self, **kwargs: Any) -> None:
        """
        Dynamically update the Mercator configuration.

        Args:
            **kwargs (Any): Configuration parameters to update.

        Raises:
            ConfigurationError: If an error occurs during update.
        """
        logger.debug(f"Updating MercatorConfig with parameters: {kwargs}")
        try:
            updated_config = self.config.copy(update=kwargs)
            self.config = updated_config
            logger.info("MercatorConfig updated successfully.")
        except Exception as e:
            error_msg = f"Failed to update MercatorConfig: {e}"
            logger.exception(error_msg)
            raise ConfigurationError(error_msg) from e

    def __getattr__(self, item: str) -> Any:
        """
        Access configuration parameters as attributes.

        Args:
            item (str): Attribute name.

        Returns:
            Any: The value of the attribute if it exists.

        Raises:
            AttributeError: If the attribute does not exist.
        """
        logger.debug(f"Accessing MercatorConfig attribute '{item}'.")
        try:
            return getattr(self.config, item)
        except AttributeError:
            error_msg = f"'MercatorConfig' object has no attribute '{item}'"
            logger.error(error_msg)
            raise AttributeError(error_msg) from None

### /Users/robinsongarcia/projects/gnomonic/projection//mercator/grid.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/mercator/grid.py

from ..base.grid import BaseGridGeneration
import numpy as np
import logging

logger = logging.getLogger('projection.mercator.grid')

class MercatorGridGeneration(BaseGridGeneration):
    """
    Grid generation for Mercator projection.
    """

    def projection_grid(self):
        """
        Generate the Mercator projection grid (lon, lat).

        Returns:
            Tuple[np.ndarray, np.ndarray]: The longitude and latitude grids for forward projection.
        """
        logger.debug("Generating Mercator projection grid.")
        y_max = np.log(np.tan(np.pi / 4 + np.radians(self.config.config.lat_max) / 2))
        y_min = np.log(np.tan(np.pi / 4 + np.radians(self.config.config.lat_min) / 2))
        lat = np.linspace(y_min, y_max, self.config.config.y_points)
        lon = np.linspace(self.config.config.lon_min, self.config.config.lon_max, self.config.config.x_points)
        lon = np.radians(lon)
        grid_lon, grid_lat = np.meshgrid(lon, lat)
        return grid_lon, grid_lat

    def spherical_grid(self):
        """
        Generate the grid for backward projection in Mercator projection.

        Returns:
            Tuple[np.ndarray, np.ndarray]: The X and Y coordinate grids (map_x, map_y).
        """
        logger.debug("Generating Mercator spherical grid.")
        x = np.linspace(self.config.config.lon_min, self.config.config.lon_max, self.config.config.x_points)
        y = np.linspace(self.config.config.lat_max, self.config.config.lat_min, self.config.config.y_points)
        map_y, map_x = np.meshgrid(x, y)
        return map_x, map_y

### /Users/robinsongarcia/projects/gnomonic/projection//mercator/strategy.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/mercator/strategy.py

from ..base.strategy import BaseProjectionStrategy
import numpy as np
import logging

logger = logging.getLogger('projection.mercator.strategy')

class MercatorProjectionStrategy(BaseProjectionStrategy):
    """
    Projection strategy for Mercator projection.
    """

    def __init__(self, config):
        """
        Initialize the MercatorProjectionStrategy with the given config.

        Args:
            config: A MercatorConfig instance.
        """
        logger.debug("Initializing MercatorProjectionStrategy.")
        self.config = config

    def from_projection_to_spherical(self, lon: np.ndarray, lat: np.ndarray):
        """
        Perform forward Mercator projection (not typical naming, but as per code).

        Args:
            lon (np.ndarray): Longitude values (radians).
            lat (np.ndarray): Latitude values for the projection (already transformed).

        Returns:
            Tuple[np.ndarray, np.ndarray]: The (lat, lon) in some form.
        """
        lon = lon / self.config.R
        lat =  np.pi / 2 - 2 * np.arctan(np.e**(lat/ self.config.R))
        logger.debug("Mercator forward projection computed successfully.")
        return lat, lon

    def from_spherical_to_projection(self, x: np.ndarray, y: np.ndarray):
        """
        Perform inverse Mercator projection (again, naming reversed in code).

        Args:
            x (np.ndarray): X coordinates (longitudes in degrees).
            y (np.ndarray): Y coordinates (latitudes in degrees).

        Returns:
            Tuple[np.ndarray, np.ndarray, np.ndarray]: The projected X, Y, and a mask.
        """
        logger.debug("Starting inverse Mercator projection (spherical to projection).")
        lon_rad = np.radians(x)
        lat_rad = np.radians(y)
        x = 1 * lon_rad
        y = 1 * np.log(np.tan(np.pi / 4 + lat_rad / 2))
        mask = np.ones_like(x) == 1
        logger.debug("Inverse Mercator projection computed successfully.")
        return x, y, mask

### /Users/robinsongarcia/projects/gnomonic/projection//mercator/transform.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/mercator/transform.py

from typing import Tuple, Any
import numpy as np
import logging
from ..exceptions import TransformationError, ConfigurationError
from ..base.transform import BaseCoordinateTransformer

logger = logging.getLogger('projection.mercator.transform')

class MercatorTransformer(BaseCoordinateTransformer):
    """
    Transformation logic for the Mercator projection.
    """

    def __init__(self, config):
        """
        Initialize the MercatorTransformer with the given configuration.

        Args:
            config: Configuration object with necessary parameters.

        Raises:
            ConfigurationError: If required attributes are missing.
        """
        logger.debug("Initializing MercatorTransformer.")
        required_attributes = ["lon_min", "lon_max", "lat_min", "lat_max", "x_points", "y_points"]
        missing_attributes = [attr for attr in required_attributes if not hasattr(config, attr)]

        if missing_attributes:
            error_msg = f"Configuration object is missing required attributes: {', '.join(missing_attributes)}"
            logger.error(error_msg)
            raise ConfigurationError(error_msg)

        self.config = config
        logger.info("MercatorTransformer initialized successfully.")

    def spherical_to_image_coords(
        self, lat: np.ndarray, lon: np.ndarray, shape: Tuple[int, int]
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Convert latitude and longitude to Mercator image coordinates.

        Args:
            lat (np.ndarray): Latitude values in degrees.
            lon (np.ndarray): Longitude values in degrees.
            shape (Tuple[int, int]): Shape of the target image (height, width).

        Returns:
            Tuple[np.ndarray, np.ndarray]: X and Y coordinates in image space.

        Raises:
            TransformationError: If input arrays are invalid or computation fails.
        """
        logger.debug("Transforming latitude and longitude to Mercator image coordinates.")
        try:
            if not isinstance(lat, np.ndarray) or not isinstance(lon, np.ndarray):
                raise TypeError("Latitude and longitude must be numpy arrays.")



            # Very simplistic placeholder logic (not a real Mercator transformation).
            x = lon
            y = lat
            map_x = ((x / np.pi) * .5 + .5) * (self.config.x_points - 1)
            map_y = (1 + -1*(( y / (np.pi/2) )* .5 + .5 ))* (self.config.y_points - 1)

            logger.debug("Latitude and longitude transformed successfully.")
            return map_x, map_y

        except Exception as e:
            logger.exception("Failed to transform latitude and longitude to Mercator image coordinates.")
            raise TransformationError(f"Mercator lat/lon transformation failed: {e}")

    def projection_to_image_coords(
        self, x: np.ndarray, y: np.ndarray, shape: Tuple[int, int]
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Transform XY grid coordinates to Mercator image coordinates.

        Args:
            x (np.ndarray): X grid coordinates.
            y (np.ndarray): Y grid coordinates.
            shape (Tuple[int, int]): Shape of the target image (height, width).

        Returns:
            Tuple[np.ndarray, np.ndarray]: X and Y coordinates in image space.

        Raises:
            TransformationError: If input arrays are invalid or computation fails.
        """
        logger.debug("Transforming XY grid coordinates to Mercator image coordinates.")
        try:
            if not isinstance(x, np.ndarray) or not isinstance(y, np.ndarray):
                raise TypeError("Grid coordinates must be numpy arrays.")

            H = self.config.y_points
            W = self.config.x_points
            lon = x
            lat = y

            y_max = np.log(np.tan(np.pi / 4 + np.radians(self.config.config.lat_max) / 2))
            y_min = np.log(np.tan(np.pi / 4 + np.radians(self.config.config.lat_min) / 2))

            map_x = ((lon / np.radians(self.config.config.lon_max)) * .5 + .5) * (self.config.x_points)

            map_y = ((lat - y_min) / (y_max - y_min)) * self.config.y_points

            logger.debug("XY grid coordinates transformed successfully.")
            return map_x, map_y

        except Exception as e:
            logger.exception("Failed to transform XY grid coordinates to Mercator image coordinates.")
            raise TransformationError(f"Mercator XY transformation failed: {e}")

### /Users/robinsongarcia/projects/gnomonic/projection//processor.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/processor.py

from typing import Any, Optional, Tuple
from .base.config import BaseProjectionConfig
from .exceptions import ProcessingError, InterpolationError, GridGenerationError, TransformationError
import logging
import cv2
import numpy as np
from .utils import PreprocessEquirectangularImage
# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.processor')

class ProjectionProcessor:
    """
    Processor for handling forward and backward projections using the provided configuration.
    """

    def __init__(self, config: BaseProjectionConfig) -> None:
        """
        Initialize the ProjectionProcessor with a given configuration.

        Args:
            config (BaseProjectionConfig): The projection configuration.

        Raises:
            TypeError: If 'config' is not an instance of BaseProjectionConfig.
            ProcessingError: If initialization of components fails.
        """
        logger.debug("Initializing ProjectionProcessor.")
        if not isinstance(config, BaseProjectionConfig):
            error_msg = f"config must be an instance of BaseProjectionConfig, got {type(config)} instead."
            logger.error(error_msg)
            raise TypeError(error_msg)

        self.config: BaseProjectionConfig = config
        try:
            self.projection = config.create_projection()
            self.grid_generation = config.create_grid_generation()
            self.interpolation = config.create_interpolation()
            self.transformer = config.create_transformer()  # Initialize transformer
            logger.info("ProjectionProcessor components initialized successfully.")
        except Exception as e:
            error_msg = f"Failed to initialize ProjectionProcessor components: {e}"
            logger.exception(error_msg)
            raise ProcessingError(error_msg) from e

    def forward(self, img: np.ndarray, **kwargs: Any) -> np.ndarray:
        """
        Forward projection of an image.

        Args:
            img (np.ndarray): The input equirectangular image.
            **kwargs (Any): Additional parameters to override projection configuration.

        Returns:
            np.ndarray: Projected rectilinear image.

        Raises:
            ValueError: If the input image is not a valid NumPy array.
            GridGenerationError: If grid generation fails.
            ProcessingError: If forward projection fails.
            TransformationError: If coordinate transformation fails.
            InterpolationError: If interpolation fails.
        """
        logger.debug("Starting forward projection.")
        if not isinstance(img, np.ndarray):
            error_msg = "Input image must be a NumPy ndarray."
            logger.error(error_msg)
            raise ValueError(error_msg)

        try:
            self.config.update(**kwargs)
            logger.debug(f"Configuration updated with parameters: {kwargs}")

            img = PreprocessEquirectangularImage.preprocess(img, **kwargs)

            x_grid, y_grid = self.grid_generation.projection_grid()
            logger.debug("Forward grid generated successfully.")

            lat, lon = self.projection.from_projection_to_spherical(x_grid, y_grid)
            logger.debug("Forward projection computed successfully.")

            map_x, map_y = self.transformer.spherical_to_image_coords(lat, lon, img.shape[:2])
            logger.debug("Coordinates transformed to image space successfully.")

            projected_img = self.interpolation.interpolate(img, map_x, map_y)
            logger.info("Forward projection completed successfully.")
            return projected_img

        except (GridGenerationError, ProcessingError, TransformationError, InterpolationError) as e:
            logger.error(f"Forward projection failed: {e}")
            raise
        except Exception as e:
            logger.exception("Unexpected error during forward projection.")
            raise ProcessingError(f"Unexpected error during forward projection: {e}")

    def backward(self, rect_img: np.ndarray, **kwargs: Any) -> np.ndarray:
        """
        Backward projection of a rectilinear image to equirectangular.

        Args:
            rect_img (np.ndarray): The rectilinear image.
            **kwargs (Any): Additional parameters to override projection configuration.

        Returns:
            np.ndarray: Back-projected equirectangular image.

        Raises:
            ValueError: If the input image is not a valid NumPy array.
            GridGenerationError: If grid generation fails.
            ProcessingError: If backward projection fails.
            TransformationError: If coordinate transformation fails.
            InterpolationError: If interpolation fails.
        """
        logger.debug("Starting backward projection.")
        if not isinstance(rect_img, np.ndarray):
            error_msg = "Rectilinear image must be a NumPy ndarray."
            logger.error(error_msg)
            raise ValueError(error_msg)

        try:
            self.config.update(**kwargs)
            logger.debug(f"Configuration updated with parameters: {kwargs}")

            
            lon_grid, lat_grid = self.grid_generation.spherical_grid()
            logger.debug("Backward grid generated successfully.")

            x, y, mask = self.projection.from_spherical_to_projection(lat_grid, lon_grid)
            logger.debug("Backward projection computed successfully.")

            map_x, map_y = self.transformer.projection_to_image_coords(x, y, self.config.config_object)
            logger.debug("Grid coordinates transformed to image space successfully.")

            back_projected_img = self.interpolation.interpolate(
                rect_img, map_x, map_y, mask if kwargs.get("return_mask", True) else None
            )
            logger.info("Backward projection completed successfully.")
            return cv2.flip(back_projected_img, 0)

        except (GridGenerationError, ProcessingError, TransformationError, InterpolationError) as e:
            logger.error(f"Backward projection failed: {e}")
            raise
        except Exception as e:
            logger.exception("Unexpected error during backward projection.")
            raise ProcessingError(f"Unexpected error during backward projection: {e}")

### /Users/robinsongarcia/projects/gnomonic/projection//registry.py ###
# /Users/robinsongarcia/projects/gnomonic/projection/registry.py

from typing import Any, Dict, Optional, Type, Union
from .base.config import BaseProjectionConfig
from .processor import ProjectionProcessor
from .exceptions import RegistrationError
import logging

# Initialize logger for this module
logger = logging.getLogger('gnomonic_projection.registry')

class ProjectionRegistry:
    """
    Registry for managing projection configurations and their components.
    """
    _registry: Dict[str, Dict[str, Type[Any]]] = {}

    @classmethod
    def register(cls, name: str, components: Dict[str, Type[Any]]) -> None:
        """
        Register a projection with its required components.

        Args:
            name (str): Name of the projection (e.g., 'gnomonic').
            components (Dict[str, Type[Any]]): A dictionary containing:
                - 'config': Configuration class
                - 'grid_generation': Grid generation class
                - 'projection_strategy': Projection strategy class
                - 'interpolation' (optional): Interpolation class
                - 'transformer': Transformation class (optional)

        Raises:
            RegistrationError: If required components are missing or invalid.
        """
        logger.debug(f"Attempting to register projection '{name}' with components: {list(components.keys())}")
        required_keys = {"config", "grid_generation", "projection_strategy"}
        missing_keys = required_keys - components.keys()
        if missing_keys:
            error_msg = f"Components must include {required_keys}. Missing keys: {missing_keys}"
            logger.error(error_msg)
            raise RegistrationError(error_msg)

        for key in ["interpolation", "transformer"]:
            if key in components:
                if not isinstance(components[key], type):
                    error_msg = f"'{key}' component must be a class type."
                    logger.error(error_msg)
                    raise RegistrationError(error_msg)
                logger.debug(f"'{key}' component validated as a class type.")

        cls._registry[name] = components
        logger.info(f"Projection '{name}' registered successfully.")

    @classmethod
    def get_projection(
        cls, 
        name: str, 
        return_processor: bool = False, 
        **kwargs: Any
    ) -> Union[BaseProjectionConfig, ProjectionProcessor]:
        """
        Retrieve a configured projection by name.

        Args:
            name (str): Name of the projection to retrieve.
            return_processor (bool): Whether to return the processor instead of the config.
            **kwargs (Any): Configuration parameters to override defaults.

        Returns:
            Union[BaseProjectionConfig, ProjectionProcessor]: Depending on `return_processor`.

        Raises:
            RegistrationError: If the projection name is not found or components are missing.
        """
        logger.debug(f"Retrieving projection '{name}' with override parameters: {kwargs}")
        if name not in cls._registry:
            error_msg = f"Projection '{name}' not found in the registry."
            logger.error(error_msg)
            raise RegistrationError(error_msg)

        components = cls._registry[name]
        try:
            ConfigClass = components["config"]
            GridGenerationClass = components["grid_generation"]
            ProjectionStrategyClass = components["projection_strategy"]
            InterpolationClass = components.get("interpolation", None)
            TransformerClass = components.get("transformer", None)
            logger.debug(f"Components for projection '{name}': {list(components.keys())}")
        except KeyError as e:
            error_msg = f"Missing component in the registry: {e}"
            logger.error(error_msg)
            raise RegistrationError(error_msg) from e

        # Instantiate the configuration object
        try:
            config_instance = ConfigClass(**kwargs)
            logger.debug(f"Configuration instance for projection '{name}' created successfully.")
        except Exception as e:
            error_msg = f"Failed to instantiate config class '{ConfigClass.__name__}': {e}"
            logger.exception(error_msg)
            raise RegistrationError(error_msg) from e

        # Create a BaseProjectionConfig and attach the necessary methods
        base_config = BaseProjectionConfig(config_instance)
        base_config.create_projection = lambda: ProjectionStrategyClass(config_instance)
        base_config.create_grid_generation = lambda: GridGenerationClass(config_instance)
        if InterpolationClass:
            base_config.create_interpolation = lambda: InterpolationClass(config_instance)
        if TransformerClass:
            base_config.create_transformer = lambda: TransformerClass(config_instance)

        if return_processor:
            logger.debug(f"Returning ProjectionProcessor for projection '{name}'.")
            return ProjectionProcessor(base_config)

        logger.debug(f"Returning BaseProjectionConfig for projection '{name}'.")
        return base_config

    @classmethod
    def list_projections(cls) -> list:
        """
        List all registered projections.

        Returns:
            list: A list of projection names.
        """
        logger.debug("Listing all registered projections.")
        projections = list(cls._registry.keys())
        logger.info(f"Registered projections: {projections}")
        return projections

### /Users/robinsongarcia/projects/gnomonic/projection//utils.py ###
import cv2
import numpy as np
import logging


class PreprocessEquirectangularImage:
    # Set up the logger for the class
    logger = logging.getLogger("EquirectangularImage")
    logger.setLevel(logging.DEBUG)

    @classmethod
    def extend_height(cls, image, fov_extra):
        """
        Extends the height of an equirectangular image based on the given additional FOV.
        """
        cls.logger.info("Starting height extension with fov_extra=%.2f", fov_extra)

        if not isinstance(image, np.ndarray):
            cls.logger.error("Image is not a valid numpy array.")
            raise TypeError("Image must be a numpy array.")
        if fov_extra <= 0:
            cls.logger.info("No extension needed as fov_extra=0.")
            return image  # No extension needed

        fov_original = 180.0
        height, width, channels = image.shape
        h_prime = int((fov_extra / fov_original) * height)
        cls.logger.debug("Original height: %d, Additional height: %d", height, h_prime)

        black_extension = np.zeros((h_prime, width, channels), dtype=image.dtype)
        extended_image = np.vstack((image, black_extension))

        cls.logger.info("Height extension complete. New height: %d", extended_image.shape[0])
        return extended_image

    @classmethod
    def rotate(cls, image, delta_lat, delta_lon):
        """
        Rotates an equirectangular image based on latitude and longitude shifts.
        """
        cls.logger.info("Starting rotation with delta_lat=%.2f, delta_lon=%.2f", delta_lat, delta_lon)

        if image.ndim != 3 or image.shape[2] not in [1, 3, 4]:
            cls.logger.error("Invalid image dimensions. Expected a 3D array with 1, 3, or 4 channels.")
            raise ValueError("Input image must be a 3D array with 1, 3, or 4 channels.")

        H, W, C = image.shape
        cls.logger.debug("Image dimensions: Height=%d, Width=%d, Channels=%d", H, W, C)

        x = np.linspace(0, W - 1, W)
        y = np.linspace(0, H - 1, H)
        xv, yv = np.meshgrid(x, y)

        lon = (xv / (W - 1)) * 360.0 - 180.0
        lat = 90.0 - (yv / (H - 1)) * 180.0

        lat_rad = np.radians(lat)
        lon_rad = np.radians(lon)
        x_sphere = np.cos(lat_rad) * np.cos(lon_rad)
        y_sphere = np.cos(lat_rad) * np.sin(lon_rad)
        z_sphere = np.sin(lat_rad)

        delta_lat_rad = np.radians(delta_lat)
        delta_lon_rad = np.radians(delta_lon)

        x_rot = x_sphere
        y_rot = y_sphere * np.cos(delta_lat_rad) - z_sphere * np.sin(delta_lat_rad)
        z_rot = y_sphere * np.sin(delta_lat_rad) + z_sphere * np.cos(delta_lat_rad)

        x_final = x_rot * np.cos(delta_lon_rad) - y_rot * np.sin(delta_lon_rad)
        y_final = x_rot * np.sin(delta_lon_rad) + y_rot * np.cos(delta_lon_rad)
        z_final = z_rot

        lon_final = np.arctan2(y_final, x_final)
        lat_final = np.arcsin(z_final)

        lon_final_deg = np.degrees(lon_final)
        lat_final_deg = np.degrees(lat_final)

        x_rot_map = ((lon_final_deg + 180.0) / 360.0) * (W - 1)
        y_rot_map = ((90.0 - lat_final_deg) / 180.0) * (H - 1)

        map_x = x_rot_map.astype(np.float32)
        map_y = y_rot_map.astype(np.float32)

        rotated_image = cv2.remap(
            image,
            map_x,
            map_y,
            interpolation=cv2.INTER_LINEAR,
            borderMode=cv2.BORDER_WRAP
        )

        cls.logger.info("Rotation complete.")
        return rotated_image

    @classmethod
    def preprocess(cls, image, **kwargs):
        """
        Preprocess an equirectangular image by extending its height and then rotating it.

        Parameters:
            image (np.ndarray): Input equirectangular image.
            **kwargs: Parameters for preprocessing:
                - fov_extra (float): Additional field of view in degrees to extend. Default is 0.
                - delta_lat (float): Latitude rotation in degrees. Default is 0.
                - delta_lon (float): Longitude rotation in degrees. Default is 0.

        Returns:
            np.ndarray: Preprocessed image.
        """
        fov_extra = kwargs.get("fov_extra", 0)
        delta_lat = kwargs.get("delta_lat", 0)
        delta_lon = kwargs.get("delta_lon", 0)

        cls.logger.info("Starting preprocessing with parameters: fov_extra=%.2f, delta_lat=%.2f, delta_lon=%.2f",
                        fov_extra, delta_lat, delta_lon)

        # Step 1: Extend the image height
        processed_image = cls.extend_height(image, fov_extra)

        # Step 2: Rotate the image
        processed_image = cls.rotate(processed_image, delta_lat, delta_lon)

        cls.logger.info("Preprocessing complete.")
        return processed_image

    @classmethod
    def save_image(cls, image, file_path):
        """
        Saves the current image to the specified file path.
        """
        if not isinstance(image, np.ndarray):
            cls.logger.error("Image is not a valid numpy array.")
            raise TypeError("Image must be a numpy array.")
        cv2.imwrite(file_path, image)
        cls.logger.info("Image saved to %s", file_path)

